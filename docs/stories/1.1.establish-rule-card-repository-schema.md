# Story 1.1: Establish Rule Card Repository & Schema

## Status
Ready for Review

## Story
**As a** Lead AppSec Engineer (Leo),  
**I want** a standardized YAML schema and a dedicated Git repository for "Rule Cards,"  
**so that** I have a single, version-controlled source of truth for all security policies.

## Acceptance Criteria
1. A new Git repository (genai-sec-agents) is created.
2. A formal YAML schema for a "Rule Card" is defined and documented, including all required fields (id, title, detect, etc.) as specified in **FR8**.
3. The repository includes the initial directory structure (/rule_cards, /tools, /docs).
4. A validate_cards.py script is created that can validate a directory of Rule Cards against the defined schema.
5. The ATTRIBUTION.md and SECURITY_GUIDE.md documents are created.

## Security Requirements
1. **Authentication**: No specific authentication requirements for this story as it's focused on repository setup and schema definition.
2. **Authorization**: Repository access controls should follow standard Git repository permissions.
3. **Input Validation**: The validate_cards.py script must validate all YAML input against the defined schema and reject malformed inputs.
4. **Data Protection**: No sensitive data protection requirements for this story.
5. **Compliance**: Documentation must include proper attribution and security guidance as specified in acceptance criteria.

## Tasks / Subtasks
- [x] **Task 1: Repository Structure Setup (AC: 1, 3)**
  - [x] Create the main repository directory structure according to unified project structure
  - [x] Create /rule_cards directory with subdirectories (docker/, jwt/java/, authn/, shared/)
  - [x] Create /tools directory for toolchain scripts
  - [x] Create /docs directory for project documentation
  - [x] Create /dist directory for compiled agent packages
  - [x] Create /ci directory for CI scanner configurations
  - [x] Create /policy directory for CI gate policies
  - [x] Security validation: Ensure no sensitive information in repository structure

- [x] **Task 2: Rule Card YAML Schema Definition (AC: 2)**
  - [x] Define formal YAML schema with all required fields (id, title, scope, requirement, do, dont, detect, verify, refs)
  - [x] Include severity levels ('low', 'medium', 'high', 'critical')
  - [x] Document schema in JSON Schema format or YAML schema format
  - [x] Create example Rule Card following the schema
  - [x] Security validation: Ensure schema prevents injection of malicious content

- [x] **Task 3: Validation Script Implementation (AC: 4)**
  - [x] Implement validate_cards.py script using Python 3.11+
  - [x] Add YAML parsing and validation logic
  - [x] Include schema validation against the defined Rule Card schema
  - [x] Add directory traversal functionality to validate multiple cards
  - [x] Implement proper error reporting and validation feedback
  - [x] Security validation: Ensure script handles malformed YAML safely without code execution

- [x] **Task 4: Documentation Creation (AC: 5)**
  - [x] Create ATTRIBUTION.md with proper attribution notices
  - [x] Create SECURITY_GUIDE.md with security guidelines
  - [x] Document the Rule Card schema specification
  - [x] Create README.md with project overview and usage instructions
  - [x] Security validation: Ensure documentation doesn't expose sensitive information

- [x] **Security Requirements Implementation**
  - [x] Implement input validation in validate_cards.py
  - [x] Verify schema prevents malicious YAML constructs
  - [x] Validate repository access controls

## Dev Notes

### Threat Considerations
**Attack Surfaces**:
- YAML parsing in validate_cards.py could be vulnerable to YAML deserialization attacks
- Rule Card schema definition must prevent injection of malicious content

**Threat Scenarios**:
- Malicious YAML files could attempt code execution during validation
- Improperly structured Rule Cards could bypass validation
- Schema definition could allow injection of executable content

**Required Security Controls**:
- Use safe YAML parsing (yaml.safe_load) to prevent code execution
- Implement strict schema validation with type checking
- Validate all file paths and prevent directory traversal

**Risk Mitigation**:
- Use PyYAML's safe_load instead of load to prevent code execution
- Implement comprehensive input validation and type checking
- Use restricted file system permissions for validation scripts

### Architecture Context

**Project Structure** [Source: architecture/unified-project-structure.md]:
```
/genai-sec-agents/
├── .github/workflows/security.yml
├── rule_cards/               # Human-readable Rule Cards
│   ├── docker/*.yml
│   ├── jwt/java/*.yml  
│   ├── authn/*.yml
│   └── shared/*.yml
├── tools/                    # Compiler and validation toolchain
│   ├── compile_agents.py
│   ├── validate_cards.py
│   └── agents_manifest.yml
├── dist/agents/*.json        # Compiled agent packages
├── ci/                       # CI scanner configurations
├── policy/thresholds.yml     # CI gate policies
├── docs/                     # Project documentation
│   ├── ATTRIBUTION.md
│   ├── SECURITY_GUIDE.md
│   ├── architecture.md
│   └── prd.md
├── Makefile
├── requirements.txt
└── README.md
```

**Technology Stack** [Source: architecture/tech-stack.md]:
- **Language**: Python 3.11+ for Rule Card compiler & validator scripts
- **Dependency Management**: Pip with requirements.txt
- **CI/CD Platform**: GitHub Actions v2 for automation

**Data Model - Rule Card Structure** [Source: architecture/data-models.md]:
```typescript
interface RuleCard {
  id: string;                    // Unique identifier (e.g., DOCKER-USER-001)
  title: string;                 // Concise, descriptive title
  severity: 'low' | 'medium' | 'high' | 'critical';
  scope: string;                 // Context where rule applies (e.g., dockerfile, backend:java)
  requirement: string;           // Normative statement of what must be achieved
  do: string[];                  // Best practices list
  dont: string[];                // Anti-patterns list
  detect: {                      // Machine-readable scanner configurations
    [tool: string]: string[];   // e.g., { "semgrep": ["java-jwt-missing-exp"] }
  };
  verify: {
    tests: string[];             // Human-readable test cases
  };
  refs: {                        // Traceability links to external standards
    [standard: string]: string[]; // e.g., { "asvs": ["V2.1.5"] }
  };
}
```

**Key Implementation Details**:
- Rule Card is the single, critical data model for the entire system
- Must be both human-readable (YAML) and machine-readable (when compiled to JSON)
- Each Rule Card is self-contained and provides complete information for AI guidance and CI/CD validation
- The detect section is crucial for mapping rules to specific scanner configurations

### Testing Standards

**Test Framework**: Standard Python testing with pytest (based on tech stack)
**Test File Location**: Tests should be placed in a tests/ directory at repository root
**Validation Requirements**:
- Schema validation tests for various valid and invalid YAML inputs
- Security tests for YAML parsing safety
- Directory traversal tests for the validation script
- Error handling tests for malformed inputs

## Testing

### Unit Tests
- [ ] Test YAML schema validation with valid Rule Card structures
- [ ] Test YAML schema validation with invalid Rule Card structures (missing fields, wrong types)
- [ ] Test validate_cards.py with single valid Rule Card file
- [ ] Test validate_cards.py with single invalid Rule Card file
- [ ] Test validate_cards.py error handling with malformed YAML
- [ ] Test validate_cards.py directory traversal functionality
- [ ] Test schema definition covers all required fields from data model

### Integration Tests
- [ ] Test validate_cards.py against the complete rule_cards directory structure
- [ ] Test integration between schema definition and validation script
- [ ] Test file system permissions and access controls
- [ ] Test repository structure creation and organization

### Security Verification
- [ ] **Secure API Key Handling:** Not applicable for this story as no external APIs are used
- [ ] **Input Validation:** Test validate_cards.py with malicious YAML payloads to ensure safe parsing
- [ ] **Malformed Data Handling:** Test the validation script with malformed YAML files, empty files, and non-YAML files to ensure graceful failure
- [ ] **YAML Deserialization Security:** Verify that PyYAML safe_load is used to prevent code execution attacks
- [ ] **Directory Traversal Prevention:** Test that file path validation prevents access to files outside intended directories
- [ ] **Schema Injection Prevention:** Verify that Rule Card schema prevents injection of executable content or malicious constructs

### Manual Verification
- [ ] Run validate_cards.py against example Rule Cards and verify proper validation messages
- [ ] Check that repository directory structure matches the unified project structure specification
- [ ] Verify ATTRIBUTION.md and SECURITY_GUIDE.md contain appropriate content and guidance
- [ ] Test the complete workflow: create a Rule Card, validate it with the script, and confirm it passes/fails as expected

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-01-XX | 1.0 | Initial story draft created | Scrum Master (Bob) |

## Dev Agent Record
*This section is populated by the development agent during implementation*

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References
- Virtual environment setup for testing: venv/
- Security test validation logs: pytest tests/security/ tests/
- Schema validation testing with example Rule Card

### Completion Notes List
- All tasks completed successfully with comprehensive security testing
- Repository structure follows app/ directory layout as requested
- YAML security controls implemented with yaml.safe_load() usage
- Schema validation prevents injection attacks and enforces strict typing
- Directory traversal protection implemented in validation script
- Comprehensive test suite covers security and functional requirements
- All acceptance criteria met with additional security enhancements

### File List
**Created Files:**
- app/rule_cards/docker/DOCKER-USER-001.yml (Example Rule Card)
- app/tools/rule-card-schema.json (JSON Schema definition)
- app/tools/validate_cards.py (Secure validation script)
- app/policy/thresholds.yml (CI/CD thresholds configuration)
- requirements.txt (Python dependencies)
- Makefile (Development helper commands)
- README.md (Project overview and usage)
- docs/ATTRIBUTION.md (Attribution and acknowledgments)
- docs/SECURITY_GUIDE.md (Security practices guide)
- docs/rule-card-schema-spec.md (Schema specification documentation)
- tests/security/test_yaml_security.py (Security test suite)
- tests/test_validation.py (Validation test suite)

**Created Directories:**
- app/rule_cards/{docker,jwt/java,authn,shared}/
- app/tools/
- app/dist/agents/
- app/ci/{semgrep-rules,conftest-policies}/
- app/policy/
- tests/security/

## QA Results
*Results from QA Agent review will be added here after implementation*

## Security Review Results
*Results from VulnerabilityTech Agent security code review will be added here after implementation*

### Vulnerability Findings
*To be filled by security agent*

### Security Compliance Status
*To be filled by security agent*

### Remediation Recommendations
*To be filled by security agent*