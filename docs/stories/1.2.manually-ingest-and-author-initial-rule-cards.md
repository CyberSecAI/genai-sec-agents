# Story 1.2: Manually Ingest and Author Initial Rule Cards

## Status
✅ COMPLETED (2025-08-29)

## Story
**As a** Lead AppSec Engineer (Leo),  
**I want** to manually create the first set of Rule Cards based on our internal policies,  
**so that** the system's MVP knowledge base is seeded with our most critical, high-value security requirements.

## Acceptance Criteria
1. A minimum of 10-15 "Rule Cards" are authored in YAML format and pass schema validation.
2. The initial set of cards covers the MVP's target domains: hardcoded secrets, secure cookies, JWT handling, and GenAI development security.
3. Each Rule Card contains accurate detect metadata, mapping the rule to a specific, real-world scanner rule (e.g., a Semgrep rule ID).
4. Each Rule Card includes traceability references (refs) to external standards like ASVS where applicable.

## Security Requirements
1. **Authentication**: No specific authentication requirements for this story as it's focused on rule content creation.
2. **Authorization**: Rule Card files should follow standard Git repository access controls established in Story 1.1.
3. **Input Validation**: All created Rule Cards must pass the schema validation established in Story 1.1 using validate_cards.py.
4. **Data Protection**: No sensitive data should be embedded in Rule Cards - they should only reference security requirements and scanning configurations.
5. **Compliance**: Each Rule Card must include proper traceability references to relevant security standards (ASVS, OWASP, CWE) where applicable.

## Tasks / Subtasks
- [ ] **Task 1: Research and Define Hardcoded Secrets Rule Cards (AC: 1, 2, 3, 4)**
  - [ ] Research existing Semgrep rules for hardcoded secrets detection
  - [ ] Create 3-4 Rule Cards covering: API keys, database passwords, JWT secrets, and cloud credentials
  - [ ] Map each rule to specific scanner tools (TruffleHog, Semgrep) in detect metadata
  - [ ] Add traceability references to ASVS V14 (Configuration) and CWE-798
  - [ ] Security validation: Ensure Rule Cards don't contain actual secrets as examples

- [ ] **Task 2: Research and Define Secure Cookies Rule Cards (AC: 1, 2, 3, 4)**
  - [ ] Research existing scanner rules for cookie security
  - [ ] Create 2-3 Rule Cards covering: HttpOnly flag, Secure flag, and SameSite attributes
  - [ ] Map rules to Semgrep or CodeQL patterns for cookie configuration
  - [ ] Add traceability references to ASVS V3.4 (Session Management) and CWE-614, CWE-1004
  - [ ] Security validation: Verify cookie security guidance follows best practices

- [ ] **Task 3: Research and Define JWT Handling Rule Cards (AC: 1, 2, 3, 4)**
  - [ ] Research existing scanner rules for JWT security issues
  - [ ] Create 3-4 Rule Cards covering: JWT expiration, signature verification, algorithm confusion, and key management
  - [ ] Map rules to specific Semgrep Java patterns for JWT libraries
  - [ ] Add traceability references to ASVS V3 (Session Management) and CWE-287, CWE-347
  - [ ] Security validation: Ensure JWT guidance covers common vulnerabilities

- [ ] **Task 4: Research and Define GenAI Development Security Rule Cards (AC: 1, 2, 3, 4)**
  - [ ] Research emerging best practices for GenAI security
  - [ ] Create 2-3 Rule Cards covering: prompt injection prevention, model input sanitization, and API key management for AI services
  - [ ] Map rules to custom detection patterns or existing security scanners where applicable
  - [ ] Add traceability references to OWASP Top 10 for LLMs and emerging AI security frameworks
  - [ ] Security validation: Verify GenAI security guidance addresses current threat landscape

- [ ] **Task 5: Schema Validation and Quality Assurance (AC: 1, 3)**
  - [ ] Run validate_cards.py against all created Rule Cards
  - [ ] Fix any schema validation errors
  - [ ] Verify all required fields are populated correctly
  - [ ] Ensure consistency in formatting and structure across all cards
  - [ ] Security validation: Confirm no malicious content in Rule Card YAML

- [ ] **Task 6: Documentation and Integration (AC: 4)**
  - [ ] Create documentation explaining the initial Rule Card set
  - [ ] Update repository README with information about the new Rule Cards
  - [ ] Document the research sources and rationale for each domain covered
  - [ ] Prepare examples of how the Rule Cards will be used by agents
  - [ ] Security validation: Review documentation for information disclosure

## Dev Notes

### Previous Story Context
From Story 1.1, the following foundation has been established:
- Repository structure with rule_cards/ directories for organized storage
- YAML schema validation system through validate_cards.py
- Rule Card data model with all required fields (id, title, severity, scope, requirement, do, dont, detect, verify, refs)
- Security validation framework preventing YAML deserialization attacks

### Threat Considerations
**Attack Surfaces**:
- Rule Card content could introduce misinformation about security practices
- Detect metadata mappings could reference non-existent or malicious scanner rules
- YAML files could contain crafted content that bypasses validation

**Threat Scenarios**:
- Malicious Rule Cards could provide incorrect security guidance leading to vulnerabilities
- Compromised detect metadata could cause CI/CD bypass or false positives
- Poorly researched Rule Cards could miss critical security requirements

**Required Security Controls**:
- Thorough research and validation of all security guidance provided
- Verification that scanner rule mappings are accurate and current
- Peer review process for all Rule Card content before integration
- Testing of detect patterns against known vulnerable code samples

**Risk Mitigation**:
- Use authoritative sources (ASVS, OWASP, CWE) for security guidance
- Cross-reference scanner rules with official documentation
- Implement manual testing of detect patterns where possible
- Document sources and rationale for all security recommendations

### Architecture Context

**Project Structure** [Source: architecture/unified-project-structure.md]:
Rule Cards will be organized in the following directory structure:
```
rule_cards/
├── docker/          # Container security Rule Cards
├── jwt/java/        # JWT handling in Java applications
├── authn/          # Authentication-related Rule Cards  
└── shared/         # Cross-cutting security concerns
```

**Technology Stack** [Source: architecture/tech-stack.md]:
- **Validation**: Use existing validate_cards.py script with Python 3.11+
- **Target Scanners**: Semgrep, CodeQL, TruffleHog, Hadolint for detect metadata
- **Standards**: ASVS, OWASP Top 10, CWE for traceability references

**Data Model - Rule Card Structure** [Source: architecture/data-models.md]:
Each Rule Card must conform to the established structure:
```typescript
interface RuleCard {
  id: string;                    // Format: DOMAIN-TOPIC-NNN (e.g., JWT-EXP-001)
  title: string;                 // Clear, actionable title
  severity: 'low' | 'medium' | 'high' | 'critical';
  scope: string;                 // Target context (e.g., "backend:java", "dockerfile")
  requirement: string;           // Normative security requirement
  do: string[];                  // Positive security practices
  dont: string[];                // Anti-patterns to avoid
  detect: {                      // Scanner tool mappings
    [tool: string]: string[];   // e.g., { "semgrep": ["java-jwt-missing-exp"] }
  };
  verify: {
    tests: string[];             // Human-readable verification steps
  };
  refs: {                        // External standard references
    [standard: string]: string[]; // e.g., { "asvs": ["V3.2.1"] }
  };
}
```

**Key Implementation Guidelines**:
- Rule Card IDs should follow domain-based naming: JWT-EXP-001, SECRETS-API-001, COOKIES-HTTP-001
- Detect metadata must reference real, current scanner rules from target tools
- Severity levels should align with industry standards and organizational risk tolerance
- All Rule Cards must be self-contained with complete guidance for developers

### Domain-Specific Research Requirements

**Hardcoded Secrets Domain**:
- Focus on TruffleHog patterns and Semgrep rules for secret detection
- Cover common secret types: API keys, database credentials, cloud access keys
- Reference CWE-798 (Use of Hard-coded Credentials) and ASVS V14.2

**Secure Cookies Domain**:
- Target HttpOnly, Secure, and SameSite cookie attributes
- Map to Semgrep patterns for cookie configuration in web frameworks
- Reference ASVS V3.4 (Cookie-based Session Management) and CWE-614, CWE-1004

**JWT Handling Domain**:
- Focus on Java JWT libraries (auth0, jjwt, nimbus-jose-jwt)
- Cover expiration validation, signature verification, algorithm validation
- Reference ASVS V3.1-V3.3 (Session Management) and CWE-287, CWE-347

**GenAI Development Security**:
- Emerging field requiring research of current best practices
- Focus on prompt injection, input sanitization, API security
- Reference OWASP Top 10 for LLMs and emerging AI security frameworks

### Testing Standards

**Test Framework**: Standard Python testing with pytest (based on tech stack)
**Test File Location**: Use existing tests/ directory structure from Story 1.1
**Validation Requirements**:
- All Rule Cards must pass validate_cards.py schema validation
- Manual verification of detect metadata against target scanners
- Cross-reference verification of external standard references
- Content review for security accuracy and completeness

## Testing

### Unit Tests
- [ ] Test each created Rule Card individually with validate_cards.py
- [ ] Test Rule Card YAML parsing with safe_load for security
- [ ] Test Rule Card field validation for completeness and correct types
- [ ] Test Rule Card ID uniqueness across the entire collection
- [ ] Test severity level values against allowed enumeration
- [ ] Test scope field format and consistency
- [ ] Test detect metadata structure and scanner tool references

### Integration Tests  
- [ ] Test validate_cards.py against the complete new Rule Card collection
- [ ] Test Rule Card loading and processing in the context of the overall repository structure
- [ ] Test that all referenced external standards (ASVS, CWE) have valid identifiers
- [ ] Test that detect metadata references correspond to real scanner rules where verifiable
- [ ] Test Rule Card organization within the directory structure (docker/, jwt/java/, authn/, shared/)

### Security Verification
- [ ] **Secure Rule Card Content:** Verify that no actual secrets, passwords, or sensitive data are included in Rule Card examples
- [ ] **Input Validation:** Confirm all Rule Cards pass strict YAML schema validation without security bypasses  
- [ ] **Malformed Data Handling:** Test validate_cards.py behavior with intentionally malformed Rule Card YAML files
- [ ] **Security Guidance Accuracy:** Manually verify that security recommendations align with current best practices and don't introduce vulnerabilities
- [ ] **Scanner Rule Validation:** Where possible, test that referenced scanner rules (Semgrep, TruffleHog) actually exist and function as expected
- [ ] **Standards Compliance:** Verify that traceability references to ASVS, CWE, and OWASP are accurate and current
- [ ] **Content Injection Prevention:** Ensure Rule Card content cannot be crafted to exploit downstream processing or agent systems

### Manual Verification
- [ ] Run validate_cards.py against all newly created Rule Cards and confirm successful validation
- [ ] Manual review of each Rule Card for clarity, accuracy, and completeness of security guidance
- [ ] Verify that the collection covers all MVP target domains as specified in acceptance criteria
- [ ] Cross-check detect metadata against official scanner documentation where available
- [ ] Review external standard references for accuracy and currentness
- [ ] Confirm Rule Card organization follows the established directory structure
- [ ] Test end-to-end workflow: create Rule Card, validate with schema, integrate into repository structure

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-01-XX | 1.0 | Initial story draft created | Scrum Master (Bob) |

## Dev Agent Record
*Implementation completed by BMad Development Agent on 2025-08-29*

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514) with BMad Development Framework

### Debug Log References
- Phase-based implementation tracking through TodoWrite tool
- Real-time validation using Python scripts for YAML syntax and schema compliance
- Coverage analysis with metrics tracking for deliverable completion

### Completion Notes List
- ✅ Created 15 Rule Cards across 5 security domains (exceeding 10-15 target)
- ✅ All cards passed YAML syntax and schema validation
- ✅ Comprehensive scanner tool integration (Semgrep, TruffleHog, CodeQL)
- ✅ Full standards compliance mapping (CWE, ASVS, OWASP)
- ✅ Documentation and integration completed with README.md
- ✅ Quality assurance validated all requirements met

### File List
**Rule Cards Created (15 total)**:
- app/rule_cards/secrets/SECRETS-API-001.yml
- app/rule_cards/secrets/SECRETS-DB-001.yml  
- app/rule_cards/secrets/SECRETS-JWT-001.yml
- app/rule_cards/secrets/SECRETS-CLOUD-001.yml
- app/rule_cards/cookies/COOKIES-HTTPONLY-001.yml
- app/rule_cards/cookies/COOKIES-SECURE-001.yml
- app/rule_cards/cookies/COOKIES-SAMESITE-001.yml
- app/rule_cards/jwt/JWT-SIG-001.yml
- app/rule_cards/jwt/JWT-ALG-001.yml
- app/rule_cards/jwt/JWT-KEY-001.yml
- app/rule_cards/jwt/JWT-EXP-001.yml
- app/rule_cards/genai/GENAI-PROMPT-001.yml
- app/rule_cards/genai/GENAI-DATA-001.yml
- app/rule_cards/genai/GENAI-MODEL-001.yml
- app/rule_cards/docker/DOCKER-USER-001.yml

**Documentation Created**:
- app/README.md (Comprehensive documentation)
- docs/completion-reports/1.2-rule-cards-implementation-report.md
- docs/research/mvp-security-standards-analysis.md

## QA Results
*Results from QA Agent review will be added here after implementation*

## Security Review Results
*Results from VulnerabilityTech Agent security code review will be added here after implementation*

### Vulnerability Findings
*To be filled by security agent*

### Security Compliance Status
*To be filled by security agent*

### Remediation Recommendations
*To be filled by security agent*