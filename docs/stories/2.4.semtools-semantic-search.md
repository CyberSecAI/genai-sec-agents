# **Story 2.4: Semtools Semantic Search Integration**

**Epic:** IDE Agent Integration (Claude Code MVP)

## **User Story**

* **As a** Deadline-Driven Developer (Daniella),
* **I want** semantic search capabilities that can find relevant security guidance from the rule card corpus when I encounter edge cases not covered by compiled rules,
* **so that** I can access comprehensive security knowledge without leaving my IDE while maintaining fast, deterministic core behavior.

## **Context and Dependencies**

This story implements the semantic search component defined in `docs/ADR/knowledge_access.md`, providing a hybrid approach that combines:
- **Compiled sub-agents** (Stories 2.1-2.3) for deterministic, low-latency core behavior
- **Local semantic search** using [semtools](https://github.com/run-llama/semtools) for extended knowledge access

**Dependencies:**
- ✅ **Story 2.1**: Agentic Runtime Core (provides agent package loading)
- ✅ **Story 2.2**: Claude Code Sub-Agent and Router (provides real-time guidance)  
- ✅ **Story 2.3**: Manual On-Demand Execution (provides comprehensive analysis commands)

## **Acceptance Criteria**

### **Task 1: Semtools Corpus Management**
1. A corpus management system can render rule cards into searchable format for semtools
2. The corpus includes all Rule Cards from the compiled agent packages plus additional OWASP guidance
3. Corpus updates are triggered automatically when rule cards change
4. The system maintains corpus versioning and freshness tracking

### **Task 2: Local Semantic Search Interface**
1. A semantic search interface can query the local corpus using semtools
2. Search queries return ranked results with provenance (source rule card, confidence score)
3. Results include contextual snippets with sufficient detail for security guidance
4. Search interface supports filtering by language, category, and severity level

### **Task 3: Feature Flag Integration**
1. Runtime retrieval is controlled by a feature flag (default: OFF)
2. When enabled, agents can optionally supplement compiled rules with semantic search results
3. All semantic search usage is logged with provenance for auditability
4. Feature flag can be toggled per-analysis or globally via configuration

### **Task 4: Developer Tools Integration**
1. Manual commands (*security-scan-file, *security-scan-workspace) can use semantic search for extended coverage
2. Search results are clearly differentiated from compiled rule results in output
3. Semantic search provides "explain mode" for understanding why specific guidance applies
4. PR review mode can use semantic search to explain security decisions and provide additional context

### **Task 5: Performance and Reliability**
1. Semantic search queries complete within 1 second for typical developer queries
2. Local corpus size is manageable (<100MB) and loads efficiently at startup
3. Graceful fallback when semantic search is unavailable (offline development)
4. Search quality is validated against known security scenarios

## **Security Requirements**

1. **Local-Only Operation**: All semantic search operates on local corpus, no external API calls
2. **Input Sanitization**: Search queries are validated to prevent injection attacks
3. **Resource Limits**: Search operations have timeout and memory limits to prevent DoS
4. **Audit Trail**: All semantic search usage is logged for security compliance
5. **Corpus Integrity**: Rule card corpus is validated for tampering before use

## **Non-Functional Requirements**

1. **NFR1 (Latency)**: Semantic search results returned within 1 second
2. **NFR2 (Consistency)**: Search results are reproducible and version-controlled
3. **NFR3 (Offline)**: Core functionality works without semantic search when offline
4. **NFR4 (Integration)**: Seamless integration with existing Stories 2.1-2.3

## **Technical Architecture**

### **Components**
```
app/
├── semantic/
│   ├── __init__.py
│   ├── corpus_manager.py      # Rule card corpus rendering and management
│   ├── semantic_search.py     # Semtools integration and search interface
│   ├── feature_flags.py       # Runtime retrieval feature flag management
│   └── search_results.py      # Search result formatting and provenance
├── claude_code/
│   ├── analyze_context.py     # Extended with semantic search integration
│   └── manual_commands.py     # Enhanced with semantic search options
└── runtime/
    └── agent_runtime.py       # Feature flag integration for compiled agents
```

### **Data Flow**
1. **Corpus Generation**: Rule cards → semtools corpus format
2. **Search Query**: Developer query → semantic search → ranked results
3. **Result Integration**: Semantic results + compiled rules → unified guidance
4. **Audit Logging**: All search operations → audit trail

## **Implementation Plan**

### **Phase 1: Foundation (2-3 days)**
- Set up semtools dependency and basic corpus structure
- Implement corpus_manager.py for rule card rendering
- Create basic semantic search interface

### **Phase 2: Search Integration (3-4 days)**
- Integrate semantic search with manual commands
- Implement feature flag system for runtime retrieval
- Add search result formatting and provenance tracking

### **Phase 3: Developer Tools (2-3 days)**
- Enhance manual commands with semantic search options
- Implement explain mode and PR review integration
- Add search quality validation

### **Phase 4: Performance & Polish (2 days)**
- Optimize search performance and corpus loading
- Implement graceful fallback and error handling
- Complete testing and documentation

## **Testing Strategy**

### **Unit Tests**
- Corpus management and rendering accuracy
- Search query processing and result ranking
- Feature flag behavior and configuration
- Result formatting and provenance tracking

### **Integration Tests**  
- Semantic search with manual commands
- Feature flag integration with existing agents
- Corpus updates and versioning workflow
- Offline operation and graceful fallback

### **Performance Tests**
- Search query latency under typical workloads
- Corpus loading time and memory usage
- Concurrent search operation handling

### **Quality Tests**
- Search result relevance for security scenarios
- Consistency of search results across versions
- Integration with existing security validation

## **Definition of Done**

- [ ] All acceptance criteria completed and tested
- [ ] Semantic search integrates seamlessly with Stories 2.1-2.3
- [ ] Feature flag system controls runtime retrieval appropriately
- [ ] Developer tools (manual commands) enhanced with semantic search
- [ ] Performance meets NFR requirements (<1s search, manageable corpus size)
- [ ] Security requirements implemented (local-only, input validation, audit trail)
- [ ] Comprehensive test coverage for all components
- [ ] Documentation updated with semantic search capabilities
- [ ] ADR requirements fully implemented per knowledge_access.md

## **Story Points**
**Estimated: 8 points** (Large - requires semtools integration, corpus management, feature flags, and performance optimization)

## **Status**
**Current Status:** Ready for Review
**Created:** 2025-08-31
**Last Updated:** 2025-08-31
**Completed:** 2025-08-31

## **Dev Agent Record**

### **Agent Model Used**
Claude 3.5 Sonnet (claude-3-5-sonnet-20241022)

### **Tasks**
- [x] Task 1: Semtools Corpus Management
- [x] Task 2: Local Semantic Search Interface  
- [x] Task 3: Feature Flag Integration
- [x] Task 4: Developer Tools Integration
- [x] Task 5: Performance and Reliability

### **Debug Log**
**2025-08-31**: Task 1 Complete - CorpusManager implementation with security features
- Created semantic search module structure with config management
- Implemented CorpusManager with rule card rendering and versioning
- Added path sanitization security to prevent directory traversal
- Comprehensive test suite created with 15+ test cases
- Module imports successfully, ready for Task 2 implementation

**2025-08-31**: Task 2 Complete - Local Semantic Search Interface with fallback
- Implemented SemanticSearchInterface with semtools integration and fallback
- Created SearchResults with provenance tracking and unified display
- Added comprehensive input validation and security controls
- Implemented context-aware search for code analysis scenarios
- Created audit logging for security compliance
- 20+ test cases covering all search functionality

**2025-08-31**: Task 3 Complete - Feature Flag Integration with security defaults
- Implemented SemanticSearchFeatureFlags with runtime retrieval control
- Runtime retrieval OFF by default per ADR security requirements
- Temporary per-analysis flags with expiration support
- Comprehensive audit logging for compliance tracking
- Global and scoped flag management with persistence
- Security validation and configuration management
- 25+ test cases covering all flag scenarios

**2025-08-31**: Task 4 Complete - Developer Tools Integration with enhanced commands
- Enhanced ManualSecurityCommands with semantic search integration
- Added analyze_file_with_semantic_search() with optional augmentation
- Implemented analyze_workspace_with_semantic_search() for edge case detection
- Created explain_security_guidance() with semantic search explanations
- Enhanced CLI with --semantic, --explain, --semantic-filters options
- Results clearly differentiate compiled vs semantic search sources
- Graceful fallback when semantic search unavailable
- 15+ integration tests covering all enhancement scenarios

**2025-08-31**: Task 5 Complete - Performance and Reliability with comprehensive testing
- Implemented <1s search performance requirement (NFR1) 
- Added graceful offline fallback capability (NFR3)
- Created comprehensive performance and reliability test suites
- Implemented concurrent search handling and resource limits
- Added search quality validation against known security scenarios
- Created complete end-to-end integration tests
- Validated all acceptance criteria and ADR compliance
- 25+ performance and reliability test cases

### **Completion Notes**

**Key Implementation Decisions:**
- **Hybrid Architecture**: Successfully implemented ADR-specified hybrid approach combining deterministic compiled rules with optional local semantic search
- **Security-First Design**: Runtime retrieval OFF by default, comprehensive input validation, path traversal protection, and audit logging throughout
- **Performance Optimization**: All searches complete within 1s NFR requirement with efficient fallback mechanisms
- **Graceful Degradation**: System works completely offline without semantic search, maintaining core functionality
- **Feature Flag Control**: Comprehensive flag system allows per-analysis temporary enablement while maintaining secure defaults

**Technical Architecture:**
- **Modular Design**: Clean separation between corpus management, search interface, feature flags, and results handling
- **Fallback Strategy**: Robust fallback search when semtools unavailable, ensuring reliability
- **Provenance Tracking**: Complete audit trail for all semantic search operations with timestamp and configuration tracking
- **Integration Pattern**: Seamless integration with existing Stories 2.1-2.3 infrastructure without breaking changes
- **Testing Strategy**: 100+ comprehensive tests covering all components, performance, reliability, and integration scenarios

**Security Implementation:**
- **Input Sanitization**: Comprehensive validation and sanitization of all search queries and parameters
- **Resource Limits**: Timeout controls (30s), file size limits (1MB), workspace limits (1000 files), query length limits (1000 chars)
- **Path Validation**: Directory traversal prevention and project boundary enforcement
- **Audit Compliance**: Complete logging of all semantic search usage with user context and timestamp tracking
- **Corpus Integrity**: SHA256 validation and tampering detection for corpus files

### **File List**
**New Files:**
- `app/semantic/__init__.py` - Semantic search module initialization
- `app/semantic/corpus_manager.py` - Rule card corpus rendering and management
- `app/semantic/semantic_search.py` - Semtools interface with fallback search
- `app/semantic/search_results.py` - Search result formatting and provenance
- `app/semantic/feature_flags.py` - Feature flag management with audit logging
- `app/semantic/config/corpus_config.yaml` - Corpus generation configuration
- `app/semantic/config/search_config.yaml` - Search behavior configuration
- `tests/semantic/test_corpus_manager.py` - Comprehensive CorpusManager test suite
- `tests/semantic/test_semantic_search.py` - SemanticSearch and SearchResults tests
- `tests/semantic/test_feature_flags.py` - FeatureFlags and configuration tests
- `tests/semantic/test_developer_tools_integration.py` - Developer tools integration tests
- `tests/semantic/test_performance_reliability.py` - Performance and reliability tests
- `tests/semantic/test_complete_integration.py` - Complete end-to-end integration tests

**Modified Files:**
- `requirements.txt` - Added semtools dependency
- `app/claude_code/manual_commands.py` - Enhanced with semantic search integration

### **Change Log**

**2025-08-31 - Story 2.4 Complete Implementation**
- Created complete semantic search module (`app/semantic/`) with 4 core components
- Added semtools dependency with graceful fallback for offline development
- Enhanced existing manual commands with semantic search integration options
- Implemented comprehensive feature flag system with security-focused defaults
- Created 6 comprehensive test suites with 100+ total test cases
- All 5 tasks completed with full acceptance criteria validation
- All 4 NFRs (Non-Functional Requirements) successfully implemented
- Complete ADR compliance validation with hybrid architecture
- Ready for integration with existing Stories 2.1-2.3 infrastructure

## **Notes**
- Implements hybrid approach from ADR: compiled rules (deterministic) + optional semantic search (flexible)
- Semtools provides local semantic search without vector database infrastructure overhead
- Feature flag ensures deterministic behavior by default, with optional enhanced coverage
- Bridges immediate rule updates (semantic search) with long-term compilation workflow