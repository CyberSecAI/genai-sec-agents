# **Story 2.4: Semtools Semantic Search Integration**

**Epic:** IDE Agent Integration (Claude Code MVP)

## **User Story**

* **As a** Deadline-Driven Developer (Daniella),
* **I want** semantic search capabilities that can find relevant security guidance from the rule card corpus when I encounter edge cases not covered by compiled rules,
* **so that** I can access comprehensive security knowledge without leaving my IDE while maintaining fast, deterministic core behavior.

## **Context and Dependencies**

This story implements the semantic search component defined in `docs/ADR/knowledge_access.md`, providing a hybrid approach that combines:
- **Compiled sub-agents** (Stories 2.1-2.3) for deterministic, low-latency core behavior
- **Local semantic search** using [semtools](https://github.com/run-llama/semtools) for extended knowledge access

**Dependencies:**
- ✅ **Story 2.1**: Agentic Runtime Core (provides agent package loading)
- ✅ **Story 2.2**: Claude Code Sub-Agent and Router (provides real-time guidance)  
- ✅ **Story 2.3**: Manual On-Demand Execution (provides comprehensive analysis commands)

## **Acceptance Criteria**

### **Task 1: Semtools Corpus Management**
1. A corpus management system can render rule cards into searchable format for semtools
2. The corpus includes all Rule Cards from the compiled agent packages plus additional OWASP guidance
3. Corpus updates are triggered automatically when rule cards change
4. The system maintains corpus versioning and freshness tracking

### **Task 2: Local Semantic Search Interface**
1. A semantic search interface can query the local corpus using semtools
2. Search queries return ranked results with provenance (source rule card, confidence score)
3. Results include contextual snippets with sufficient detail for security guidance
4. Search interface supports filtering by language, category, and severity level

### **Task 3: Feature Flag Integration**
1. Runtime retrieval is controlled by a feature flag (default: OFF)
2. When enabled, agents can optionally supplement compiled rules with semantic search results
3. All semantic search usage is logged with provenance for auditability
4. Feature flag can be toggled per-analysis or globally via configuration

### **Task 4: Developer Tools Integration**
1. Manual commands (*security-scan-file, *security-scan-workspace) can use semantic search for extended coverage
2. Search results are clearly differentiated from compiled rule results in output
3. Semantic search provides "explain mode" for understanding why specific guidance applies
4. PR review mode can use semantic search to explain security decisions and provide additional context

### **Task 5: Performance and Reliability**
1. Semantic search queries complete within 1 second for typical developer queries
2. Local corpus size is manageable (<100MB) and loads efficiently at startup
3. Graceful fallback when semantic search is unavailable (offline development)
4. Search quality is validated against known security scenarios

## **Security Requirements**

1. **Local-Only Operation**: All semantic search operates on local corpus, no external API calls
2. **Input Sanitization**: Search queries are validated to prevent injection attacks
3. **Resource Limits**: Search operations have timeout and memory limits to prevent DoS
4. **Audit Trail**: All semantic search usage is logged for security compliance
5. **Corpus Integrity**: Rule card corpus is validated for tampering before use

## **Non-Functional Requirements**

1. **NFR1 (Latency)**: Semantic search results returned within 1 second
2. **NFR2 (Consistency)**: Search results are reproducible and version-controlled
3. **NFR3 (Offline)**: Core functionality works without semantic search when offline
4. **NFR4 (Integration)**: Seamless integration with existing Stories 2.1-2.3

## **Technical Architecture**

### **Components**
```
app/
├── semantic/
│   ├── __init__.py
│   ├── corpus_manager.py      # Rule card corpus rendering and management
│   ├── semantic_search.py     # Semtools integration and search interface
│   ├── feature_flags.py       # Runtime retrieval feature flag management
│   └── search_results.py      # Search result formatting and provenance
├── claude_code/
│   ├── analyze_context.py     # Extended with semantic search integration
│   └── manual_commands.py     # Enhanced with semantic search options
└── runtime/
    └── agent_runtime.py       # Feature flag integration for compiled agents
```

### **Data Flow**
1. **Corpus Generation**: Rule cards → semtools corpus format
2. **Search Query**: Developer query → semantic search → ranked results
3. **Result Integration**: Semantic results + compiled rules → unified guidance
4. **Audit Logging**: All search operations → audit trail

## **Implementation Plan**

### **Phase 1: Foundation (2-3 days)**
- Set up semtools dependency and basic corpus structure
- Implement corpus_manager.py for rule card rendering
- Create basic semantic search interface

### **Phase 2: Search Integration (3-4 days)**
- Integrate semantic search with manual commands
- Implement feature flag system for runtime retrieval
- Add search result formatting and provenance tracking

### **Phase 3: Developer Tools (2-3 days)**
- Enhance manual commands with semantic search options
- Implement explain mode and PR review integration
- Add search quality validation

### **Phase 4: Performance & Polish (2 days)**
- Optimize search performance and corpus loading
- Implement graceful fallback and error handling
- Complete testing and documentation

## **Testing Strategy**

### **Unit Tests**
- Corpus management and rendering accuracy
- Search query processing and result ranking
- Feature flag behavior and configuration
- Result formatting and provenance tracking

### **Integration Tests**  
- Semantic search with manual commands
- Feature flag integration with existing agents
- Corpus updates and versioning workflow
- Offline operation and graceful fallback

### **Performance Tests**
- Search query latency under typical workloads
- Corpus loading time and memory usage
- Concurrent search operation handling

### **Quality Tests**
- Search result relevance for security scenarios
- Consistency of search results across versions
- Integration with existing security validation

## **Definition of Done**

- [ ] All acceptance criteria completed and tested
- [ ] Semantic search integrates seamlessly with Stories 2.1-2.3
- [ ] Feature flag system controls runtime retrieval appropriately
- [ ] Developer tools (manual commands) enhanced with semantic search
- [ ] Performance meets NFR requirements (<1s search, manageable corpus size)
- [ ] Security requirements implemented (local-only, input validation, audit trail)
- [ ] Comprehensive test coverage for all components
- [ ] Documentation updated with semantic search capabilities
- [ ] ADR requirements fully implemented per knowledge_access.md

## **Story Points**
**Estimated: 8 points** (Large - requires semtools integration, corpus management, feature flags, and performance optimization)

## **Status**
**Current Status:** Draft
**Created:** 2025-08-31
**Last Updated:** 2025-08-31

## **Notes**
- Implements hybrid approach from ADR: compiled rules (deterministic) + optional semantic search (flexible)
- Semtools provides local semantic search without vector database infrastructure overhead
- Feature flag ensures deterministic behavior by default, with optional enhanced coverage
- Bridges immediate rule updates (semantic search) with long-term compilation workflow