# **Implementation Plan: Story 2.4 - Semtools Semantic Search Integration**

## **Architecture Context**

This implementation extends the existing agent infrastructure (Stories 2.1-2.3) with local semantic search capabilities using semtools, following the hybrid approach defined in `docs/ADR/knowledge_access.md`.

### **Existing Infrastructure Integration**
- **AgenticRuntime** (2.1): Enhanced to support feature flags and semantic search results
- **Sub-Agent Router** (2.2): Optionally augmented with semantic search for edge cases  
- **Manual Commands** (2.3): Extended with semantic search options and explain mode

### **New Components Architecture**
```
app/semantic/                    # New semantic search module
├── corpus_manager.py           # Rule card corpus rendering and versioning
├── semantic_search.py          # Semtools integration and search interface  
├── feature_flags.py            # Runtime retrieval configuration
├── search_results.py           # Result formatting and provenance
└── config/                     # Configuration and corpus storage
    ├── corpus_config.yaml      # Corpus generation settings
    └── search_config.yaml      # Search behavior configuration
```

## **Phase 1: Foundation & Corpus Management (2-3 days)**

### **1.1 Semtools Integration Setup**
- Add semtools dependency to requirements.txt
- Create semantic module structure
- Set up basic configuration management

### **1.2 Corpus Manager Implementation** 
**File: `app/semantic/corpus_manager.py`**
```python
class CorpusManager:
    """Manages rule card corpus rendering and versioning for semantic search."""
    
    def render_corpus_from_packages(self, agent_packages: List[str]) -> CorpusData:
        """Render compiled agent packages into searchable corpus."""
        
    def update_corpus_incremental(self, new_rules: List[RuleCard]) -> bool:
        """Update corpus with new rule cards incrementally."""
        
    def validate_corpus_integrity(self, corpus_path: str) -> ValidationResult:
        """Validate corpus against tampering and corruption."""
        
    def get_corpus_metadata(self) -> CorpusMetadata:
        """Get corpus version, freshness, and statistics."""
```

### **1.3 Basic Semantic Search Interface**
**File: `app/semantic/semantic_search.py`**
```python
class SemanticSearchInterface:
    """Local semantic search using semtools for rule card corpus."""
    
    def __init__(self, corpus_path: str, config: SearchConfig):
        """Initialize semtools with local corpus."""
        
    def search_query(self, query: str, filters: SearchFilters = None) -> SearchResults:
        """Execute semantic search query with optional filters."""
        
    def search_by_context(self, code_context: str, language: str) -> SearchResults:
        """Context-aware search for code analysis scenarios."""
```

### **1.4 Corpus Generation Pipeline**
- Implement rule card extraction from agent packages
- Create semtools-compatible corpus format
- Set up corpus versioning and freshness tracking

## **Phase 2: Feature Flags & Search Integration (3-4 days)**

### **2.1 Feature Flag System**
**File: `app/semantic/feature_flags.py`**
```python
class SemanticSearchFeatureFlags:
    """Feature flag management for semantic search capabilities."""
    
    @staticmethod
    def is_runtime_retrieval_enabled(scope: str = "global") -> bool:
        """Check if runtime retrieval is enabled for given scope."""
        
    @staticmethod
    def enable_for_analysis(analysis_id: str, duration: int = 3600) -> None:
        """Temporarily enable semantic search for specific analysis."""
        
    @staticmethod  
    def get_search_configuration() -> SearchConfiguration:
        """Get current search behavior configuration."""
```

### **2.2 Manual Commands Enhancement**
**File: `app/claude_code/manual_commands.py` (Enhancement)**
```python
# Add to ManualSecurityCommands class
def analyze_file_with_semantic_search(self, file_path: str, semantic_enabled: bool = False) -> SecurityAnalysisResults:
    """Enhanced file analysis with optional semantic search augmentation."""
    
def analyze_workspace_with_semantic_search(self, workspace_path: str, semantic_options: SemanticSearchOptions = None) -> SecurityAnalysisResults:
    """Enhanced workspace analysis with semantic search for edge cases."""
    
def explain_security_guidance(self, rule_id: str, code_context: str) -> ExplanationResults:
    """Provide detailed explanation using semantic search for context."""
```

### **2.3 Search Result Integration**
**File: `app/semantic/search_results.py`**
```python
class SemanticSearchResults:
    """Formatted search results with provenance and confidence scoring."""
    
    def __init__(self, query: str, results: List[SearchMatch]):
        self.query = query
        self.results = results
        self.provenance = self._generate_provenance()
        
    def format_for_display(self, format_type: str = "ide") -> str:
        """Format results for IDE display with clear semantic/compiled differentiation."""
        
    def merge_with_compiled_rules(self, compiled_results: List[RuleMatch]) -> UnifiedResults:
        """Merge semantic search results with compiled rule matches."""
```

### **2.4 Audit Logging Integration**
- Implement comprehensive audit trail for all semantic search usage
- Add provenance tracking for result sources and confidence
- Create security compliance logging for enterprise requirements

## **Phase 3: Developer Tools & Advanced Features (2-3 days)**

### **3.1 Explain Mode Implementation**
```python
class ExplainMode:
    """Semantic search-powered explanation of security guidance."""
    
    def explain_rule_application(self, rule_id: str, code_snippet: str) -> ExplanationResult:
        """Explain why a specific rule applies to given code."""
        
    def find_related_guidance(self, primary_issue: str, language: str) -> RelatedGuidanceResults:
        """Find additional related security guidance using semantic similarity."""
        
    def compare_security_approaches(self, approach_a: str, approach_b: str) -> ComparisonResult:
        """Compare different security implementation approaches."""
```

### **3.2 PR Review Integration**
- Enhance manual commands with PR review mode
- Implement diff-aware semantic search for code changes
- Add batch processing for multiple file analysis

### **3.3 Advanced Search Capabilities**
```python
class AdvancedSearchFeatures:
    """Advanced semantic search features for complex scenarios."""
    
    def search_by_vulnerability_type(self, cwe_id: str, context_filters: List[str]) -> SearchResults:
        """Search for guidance specific to CWE categories."""
        
    def search_framework_specific(self, framework: str, security_domain: str) -> SearchResults:
        """Framework-specific security guidance search."""
        
    def search_compliance_requirements(self, standard: str, requirement_id: str) -> SearchResults:
        """Search for compliance-specific security guidance."""
```

## **Phase 4: Performance Optimization & Polish (2 days)**

### **4.1 Performance Optimization**
- Implement corpus indexing and caching strategies
- Optimize semtools configuration for <1s query response
- Add concurrent search handling and resource management

### **4.2 Graceful Fallback System**
```python
class SemanticSearchFallback:
    """Graceful degradation when semantic search is unavailable."""
    
    def __init__(self, compiled_rules_provider: AgenticRuntime):
        self.fallback_provider = compiled_rules_provider
        
    def handle_search_failure(self, original_query: str) -> FallbackResults:
        """Provide fallback results using compiled rules only."""
        
    def verify_offline_capability(self) -> bool:
        """Ensure core functionality works without semantic search."""
```

### **4.3 Quality Validation**
- Implement search result quality metrics
- Create validation scenarios for security guidance accuracy
- Add regression testing for search consistency

### **4.4 Error Handling & Monitoring**
- Comprehensive error handling for corpus corruption, semtools failures
- Performance monitoring and alerting for search latency
- Resource usage monitoring and limits

## **Integration Points**

### **With Story 2.1 (Agentic Runtime)**
```python
# Enhanced AgenticRuntime with semantic search support
class AgenticRuntime:
    def load_agent_package_with_semantic(self, package_path: str, enable_semantic: bool = False) -> EnhancedAgentPackage:
        """Load agent package with optional semantic search augmentation."""
        
    def select_rules_with_semantic_fallback(self, context: AnalysisContext, semantic_enabled: bool) -> RuleSelection:
        """Select rules with semantic search fallback for edge cases."""
```

### **With Story 2.2 (Sub-Agent Router)**
```python
# Enhanced sub-agent with semantic search capability
class SecurityGuidanceSubAgent:
    def provide_guidance_with_semantic(self, code_context: str, semantic_options: SemanticOptions = None) -> GuidanceResults:
        """Provide guidance with optional semantic search augmentation."""
```

### **With Story 2.3 (Manual Commands)**
```python
# Enhanced manual commands with semantic search options
def security_scan_file_semantic(file_path: str, depth: str = "standard", semantic: bool = False) -> AnalysisResults:
    """File analysis with optional semantic search for comprehensive coverage."""
    
def security_scan_workspace_semantic(workspace_path: str, depth: str = "standard", semantic_options: SemanticOptions = None) -> AnalysisResults:
    """Workspace analysis with semantic search for edge case detection."""
```

## **Configuration Management**

### **Corpus Configuration (`app/semantic/config/corpus_config.yaml`)**
```yaml
corpus:
  sources:
    - compiled_agent_packages: "packages/compiled/*.json"
    - rule_cards: "rule_cards/**/*.yaml"
    - owasp_guidance: "external/owasp/**/*.md"
  
  output:
    format: "semtools_v1"
    path: "semantic/corpus/"
    max_size_mb: 100
    
  versioning:
    track_sources: true
    auto_update: false
    freshness_check: true
```

### **Search Configuration (`app/semantic/config/search_config.yaml`)**
```yaml
search:
  performance:
    max_query_time_seconds: 1.0
    max_results: 50
    cache_enabled: true
    
  filters:
    languages: ["python", "javascript", "java", "go", "rust"]
    categories: ["authentication", "authorization", "input_validation", "crypto"]
    severity_levels: ["critical", "high", "medium", "low"]
    
  feature_flags:
    runtime_retrieval_default: false
    explain_mode_default: true
    pr_review_mode_default: false
```

## **Testing Strategy Implementation**

### **Unit Tests Structure**
```
tests/semantic/
├── test_corpus_manager.py      # Corpus rendering and management
├── test_semantic_search.py     # Search interface and semtools integration  
├── test_feature_flags.py       # Feature flag behavior
├── test_search_results.py      # Result formatting and provenance
└── test_integration.py         # Integration with existing stories
```

### **Performance Test Scenarios**
- Corpus loading time (<2s for 100MB corpus)
- Query response time (<1s for typical security queries)
- Concurrent query handling (10+ simultaneous queries)
- Memory usage under load (<500MB total for semantic search)

### **Quality Validation Scenarios**
- Security guidance accuracy for common vulnerabilities
- Search result relevance for framework-specific queries
- Consistency across corpus versions and updates
- Integration quality with compiled rules

## **Deployment Considerations**

### **Corpus Management in Production**
- Automated corpus updates from rule card changes
- Version control integration for corpus tracking  
- Rollback capability for corpus corruption
- Multi-environment corpus management (dev/staging/prod)

### **Performance Monitoring**
- Search query latency tracking
- Corpus freshness monitoring  
- Feature flag usage analytics
- Error rate and fallback usage tracking

## **Success Metrics**

1. **Performance**: <1s average search query response time
2. **Quality**: >95% developer satisfaction with semantic search results
3. **Integration**: Seamless operation with existing Stories 2.1-2.3
4. **Reliability**: <1% search failure rate with graceful fallback
5. **Adoption**: Feature flag enables semantic search for specific use cases without impacting core deterministic behavior

This implementation plan provides a comprehensive roadmap for integrating semtools semantic search while maintaining the deterministic, high-performance foundation established in Stories 2.1-2.3.