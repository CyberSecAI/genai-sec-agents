# Story 2.5: OWASP Cheat Sheet Ingestion - Implementation Plan

## Plan Overview
**Story ID:** 2.5  
**Focus:** GitHub-Based OWASP Cheat Sheets with ChatGPT Processing  
**Estimated Effort:** 8 story points (reduced from 13 due to LLM approach)  
**Target:** 40+ Rule Cards from secure coding cheat sheets via automated generation  

## Secure Coding OWASP Cheat Sheet Scope

### Priority 1: Core Secure Coding (15 cheat sheets)
- **Input Validation Cheat Sheet** - Core secure coding practice
- **SQL Injection Prevention Cheat Sheet** - Critical vulnerability prevention
- **Cross Site Scripting Prevention Cheat Sheet** - XSS mitigation
- **Cross-Site Request Forgery Prevention Cheat Sheet** - CSRF protection
- **Authentication Cheat Sheet** - Secure authentication patterns
- **Session Management Cheat Sheet** - Session security
- **Cryptographic Storage Cheat Sheet** - Data protection
- **Error Handling Cheat Sheet** - Information disclosure prevention
- **Logging Cheat Sheet** - Security logging practices
- **File Upload Cheat Sheet** - File handling security
- **HTTP Headers Cheat Sheet** - Security headers implementation
- **Content Security Policy Cheat Sheet** - CSP configuration
- **Clickjacking Defense Cheat Sheet** - UI security
- **DOM based XSS Prevention Cheat Sheet** - Client-side security
- **Unvalidated Redirects and Forwards Cheat Sheet** - Redirect security

### Priority 2: Language-Specific Secure Coding (8 cheat sheets)
- **Java Security Cheat Sheet** - Java secure coding
- **.NET Security Cheat Sheet** - .NET secure practices
- **Python Security Cheat Sheet** - Python secure coding
- **Node.js Security Cheat Sheet** - Node.js security
- **C# (.NET) Security Cheat Sheet** - C# specific practices
- **PHP Security Cheat Sheet** - PHP secure coding
- **Ruby Security Cheat Sheet** - Ruby secure practices
- **Go Security Cheat Sheet** - Go language security

### Priority 3: Framework-Specific Secure Coding (7 cheat sheets)
- **Spring Security Cheat Sheet** - Spring framework security
- **Django Security Cheat Sheet** - Django secure practices
- **React Security Cheat Sheet** - React application security
- **Angular Security Cheat Sheet** - Angular security patterns
- **Vue.js Security Cheat Sheet** - Vue.js security
- **Express.js Security Cheat Sheet** - Express security
- **Laravel Security Cheat Sheet** - Laravel secure coding

**Total Target: 30 cheat sheets → ~40-50 Rule Cards (automated via ChatGPT)**

### **Example GitHub URLs**
```
https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Input_Validation_Cheat_Sheet.md
https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.md
https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md
https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md
```

## GitHub-ChatGPT Implementation Approach

### **Content Source Strategy**
- **Repository**: OWASP CheatSheetSeries GitHub repository
- **Direct Access**: Fetch markdown via `raw.githubusercontent.com` URLs
- **Example URL**: `https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.md`
- **Raw URL Format**: `https://raw.githubusercontent.com/OWASP/CheatSheetSeries/master/cheatsheets/{FILENAME}.md`

### **ChatGPT Processing Workflow**
1. **Fetch**: Download raw markdown from specific GitHub cheat sheet URL
2. **Prepare**: Extract and clean markdown content for LLM processing  
3. **Generate**: Submit to ChatGPT API with:
   - Raw OWASP markdown content
   - Example Rule Card YAML template
   - Structured generation instructions
4. **Validate**: Parse and validate generated Rule Card YAML
5. **Integrate**: Add to existing rule card collection

### **Script-Based Automation**
```python
# Core workflow per cheat sheet
def process_cheat_sheet(github_url: str) -> List[RuleCard]:
    # 1. Fetch markdown from GitHub
    markdown_content = fetch_from_github(github_url)
    
    # 2. Process with ChatGPT + example template
    rule_cards_yaml = chatgpt_generate_rules(
        content=markdown_content,
        example_template=EXAMPLE_RULE_CARD_YAML,
        instructions=GENERATION_INSTRUCTIONS
    )
    
    # 3. Validate and return structured rule cards
    return validate_and_parse_yaml(rule_cards_yaml)
```

## Technical Implementation Plan

### Task 1: GitHub Content Acquisition and ChatGPT Integration
**Duration:** 2 days  

#### 1.1 GitHub Markdown Fetcher Implementation
```python
# app/ingestion/owasp_fetcher.py
class OWASPFetcher:
    SECURE_CODING_CHEATSHEETS = {
        'input-validation': 'https://raw.githubusercontent.com/OWASP/CheatSheetSeries/master/cheatsheets/Input_Validation_Cheat_Sheet.md',
        'sql-injection': 'https://raw.githubusercontent.com/OWASP/CheatSheetSeries/master/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.md',
        'xss-prevention': 'https://raw.githubusercontent.com/OWASP/CheatSheetSeries/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md',
        # ... 30 total GitHub raw markdown URLs
    }
    
    def fetch_markdown_from_github(self, cheat_sheet_id: str) -> str:
        """Fetch raw markdown directly from GitHub repository"""
        
    def cache_content(self, content: str, sheet_id: str) -> str:
        """Cache with SHA256 integrity validation"""
        
    def get_github_commit_hash(self, sheet_id: str) -> str:
        """Track GitHub commit for version control"""
```

#### 1.2 ChatGPT Rule Card Generator Implementation
```python
# app/ingestion/llm_rule_generator.py
class LLMRuleCardGenerator:
    def __init__(self, openai_api_key: str):
        """Initialize with user's OpenAI API key"""
        
    def generate_rule_cards(self, markdown_content: str, cheat_sheet_name: str) -> List[str]:
        """Generate Rule Card YAML using ChatGPT with example template"""
        prompt = self._create_structured_prompt(markdown_content, cheat_sheet_name)
        return self._call_chatgpt_api(prompt)
        
    def _create_structured_prompt(self, content: str, name: str) -> str:
        """Create prompt with OWASP content + example Rule Card YAML"""
        return f"""
        Convert this OWASP cheat sheet to Rule Card YAML format.
        
        OWASP Content:
        {content}
        
        Example Rule Card Format:
        {EXAMPLE_RULE_CARD_YAML}
        
        Generate 1-3 Rule Cards following this exact YAML structure.
        """
```

#### 1.3 Content Processing Pipeline
```python
# app/ingestion/content_parser.py
class SecureCodingParser:
    def parse_cheatsheet_sections(self, html_content: str) -> List[ContentSection]:
        """Extract structured sections from OWASP HTML"""
        
    def extract_code_examples(self, section: ContentSection) -> List[CodeExample]:
        """Extract secure/insecure code examples"""
        
    def identify_actionable_requirements(self, content: str) -> List[SecurityRequirement]:
        """Parse content for actionable security requirements"""
```

**Validation Commands:**
```bash
python3 -c "from app.ingestion import OWASPFetcher; f = OWASPFetcher(); print(len(f.fetch_secure_coding_cheatsheets()))"
python3 -m pytest tests/ingestion/test_owasp_fetcher.py -v
```

### Task 2: Automated Rule Card Generation via ChatGPT
**Duration:** 3 days

#### 2.1 Batch Processing Script
```python
# batch_generate_rules.py
def process_all_cheat_sheets(api_key: str) -> Dict[str, List[str]]:
    """Process all 30 cheat sheets through ChatGPT"""
    fetcher = OWASPFetcher()
    generator = LLMRuleCardGenerator(api_key)
    
    results = {}
    for sheet_id, github_url in fetcher.SECURE_CODING_CHEATSHEETS.items():
        # Fetch markdown from GitHub
        markdown = fetcher.fetch_markdown_from_github(sheet_id)
        
        # Generate Rule Cards via ChatGPT
        rule_cards = generator.generate_rule_cards(markdown, sheet_id)
        
        # Validate generated YAML
        validated_cards = validate_rule_card_yaml(rule_cards)
        results[sheet_id] = validated_cards
        
    return results
```

#### 2.2 Example Template Integration
```python
# app/ingestion/rule_card_generator.py
class SecureCodingRuleCardGenerator:
    def generate_rule_cards_from_section(self, section: ContentSection) -> List[RuleCard]:
        """Convert OWASP section to multiple Rule Cards"""
        
    def normalize_severity_mapping(self, owasp_content: str) -> SeverityLevel:
        """Map OWASP guidance to our severity levels"""
        
    def extract_dos_and_donts(self, content: str) -> Tuple[List[str], List[str]]:
        """Extract actionable do/don't guidance"""
        
    def generate_yaml_output(self, rule_card: RuleCard) -> str:
        """Generate valid Rule Card YAML"""
```

#### 2.2 Rule Card Schema Compliance
```yaml
# Example generated Rule Card from Input Validation cheat sheet
id: INPUT-VALIDATION-WHITELIST-001
title: "Use allowlist validation for user input"
severity: high
scope: web-application
requirement: "All user input must be validated against a predefined allowlist of acceptable values"
do:
  - "Define explicit allowlists for expected input values"
  - "Validate input length, format, and content"
  - "Reject any input not matching allowlist criteria"
dont:
  - "Rely solely on blacklist validation approaches"
  - "Trust user input without validation"
  - "Use regex alone for complex validation scenarios"
detect:
  semgrep:
    - "owasp.input-validation.missing-whitelist"
  custom:
    - "Check for raw user input usage without validation"
verify:
  tests:
    - "Input validation unit tests with edge cases"
    - "Penetration testing of input endpoints"
refs:
  cwe:
    - "CWE-20"
  owasp:
    - "A03:2021-Injection"
  source:
    - "OWASP Input Validation Cheat Sheet"
```

**Validation Commands:**
```bash
python3 -c "from app.ingestion import SecureCodingRuleCardGenerator; g = SecureCodingRuleCardGenerator(); print(g.validate_generated_cards())"
python3 app/tools/validate_cards.py app/rule_cards/owasp/
```

### Task 3: Scanner Integration Mapping
**Duration:** 2 days

#### 3.1 Scanner Rule Mapping
```python
# app/ingestion/scanner_mapper.py
class SecurityScannerMapper:
    SEMGREP_RULES_DB = {
        'input-validation': ['python.django.security.audit.avoid-unsafe-deserialization',
                           'python.flask.security.audit.direct-use-of-jinja2'],
        'sql-injection': ['python.sqlalchemy.security.audit.sqlalchemy-execute-raw-query',
                         'python.django.security.injection.sql.django-sql-injection'],
    }
    
    def map_owasp_to_semgrep(self, rule_card: RuleCard) -> List[str]:
        """Map Rule Card to existing Semgrep rules"""
        
    def create_custom_semgrep_rule(self, rule_card: RuleCard) -> str:
        """Generate custom Semgrep rule when no existing match"""
        
    def validate_scanner_integration(self, rule_card: RuleCard) -> bool:
        """Ensure scanner rules actually detect the vulnerability"""
```

**Validation Commands:**
```bash
semgrep --config=auto tests/sample_vulnerable_code/
python3 -m pytest tests/ingestion/test_scanner_mapping.py -v
```

### Task 4: Corpus Integration and Semantic Enhancement
**Duration:** 1 day

#### 4.1 Semantic Search Integration
```python
# Modify app/semantic/corpus_manager.py
class CorpusManager:
    def integrate_owasp_rule_cards(self, owasp_cards: List[RuleCard]) -> None:
        """Add OWASP Rule Cards to semantic search corpus"""
        
    def tag_owasp_provenance(self, content: str, source_sheet: str) -> str:
        """Tag content with OWASP source for provenance tracking"""
        
    def maintain_corpus_size_limit(self, max_size_mb: int = 100) -> None:
        """Ensure corpus stays under size limit"""
```

**Validation Commands:**
```bash
python3 -c "from app.semantic import CorpusManager; cm = CorpusManager(); print(f'Corpus size: {cm.get_corpus_size_mb()}MB')"
python3 -c "from app.semantic import SemanticSearchInterface; si = SemanticSearchInterface(); results = si.search_query('input validation'); print(f'Results: {len(results.matches)}')"
```

### Task 5: Ingestion Pipeline and Automation
**Duration:** 1 day

#### 5.1 Pipeline Orchestration
```python
# app/ingestion/ingestion_pipeline.py
class SecureCodingIngestionPipeline:
    def run_full_ingestion(self) -> IngestionReport:
        """Execute complete secure coding cheat sheet ingestion"""
        
    def validate_pipeline_output(self, generated_cards: List[RuleCard]) -> ValidationReport:
        """Comprehensive validation of generated Rule Cards"""
        
    def generate_ingestion_report(self, results: IngestionResults) -> str:
        """Generate detailed report of ingestion process"""
```

**Pipeline Execution:**
```bash
python3 -m app.ingestion.ingestion_pipeline --mode=secure-coding-only --validate
```

### Task 6: Quality Assurance and Validation
**Duration:** 1 day

#### 6.1 Quality Metrics
```python
# app/ingestion/quality_validator.py
class QualityValidator:
    def measure_content_coverage(self, original_cheatsheet: str, generated_cards: List[RuleCard]) -> float:
        """Measure % of actionable content captured"""
        
    def validate_rule_card_accuracy(self, card: RuleCard, source_content: str) -> float:
        """Validate accuracy against source content"""
        
    def check_schema_compliance(self, cards: List[RuleCard]) -> List[ValidationError]:
        """Ensure all generated cards follow schema"""
```

**Quality Validation:**
```bash
python3 -c "from app.ingestion import QualityValidator; qv = QualityValidator(); report = qv.validate_all_generated_cards(); print(f'Quality Score: {report.overall_score}')"
```

## Integration Testing Strategy

### End-to-End Integration Test
```python
# tests/ingestion/test_complete_secure_coding_ingestion.py
def test_complete_secure_coding_pipeline():
    """Test full pipeline from OWASP fetch to semantic search integration"""
    
    # 1. Fetch secure coding cheat sheets
    fetcher = OWASPFetcher()
    content = fetcher.fetch_secure_coding_cheatsheets()
    assert len(content) >= 15  # Minimum priority 1 cheat sheets
    
    # 2. Generate Rule Cards
    generator = SecureCodingRuleCardGenerator()
    rule_cards = generator.process_all_content(content)
    assert len(rule_cards) >= 40  # Target rule card count
    
    # 3. Validate schema compliance
    for card in rule_cards:
        assert validate_rule_card_schema(card)
    
    # 4. Test scanner integration
    mapper = SecurityScannerMapper()
    for card in rule_cards:
        scanner_rules = mapper.get_scanner_rules(card)
        assert len(scanner_rules) > 0
    
    # 5. Test semantic search integration
    corpus_manager = CorpusManager()
    corpus_manager.integrate_owasp_rule_cards(rule_cards)
    
    search_interface = SemanticSearchInterface()
    results = search_interface.search_query("input validation secure coding")
    assert len(results.matches) > 0
    assert any("OWASP" in match.source for match in results.matches)
    
    # 6. Performance validation
    assert corpus_manager.get_corpus_size_mb() < 100
    
    start_time = time.time()
    results = search_interface.search_query("SQL injection prevention")
    search_time = time.time() - start_time
    assert search_time < 1.0  # NFR1 requirement
```

## Performance Requirements Validation

### Load Testing
```bash
# Test with generated Rule Cards
python3 app/claude_code/analyze_context.py test_file.py --semantic
# Should complete in <2s even with expanded corpus

# Test ingestion performance
time python3 -m app.ingestion.ingestion_pipeline --mode=secure-coding-only
# Should complete in <10 minutes
```

## Risk Mitigation

### High Risk: OWASP Content Format Changes
- **Mitigation**: Robust parsing with fallback mechanisms
- **Detection**: Automated testing with known cheat sheet samples
- **Response**: Parser updates and regression testing

### Medium Risk: Generated Rule Card Quality
- **Mitigation**: Manual review sampling and quality metrics
- **Detection**: Accuracy validation against source content
- **Response**: Generator refinement and validation enhancement

### Low Risk: Performance Impact
- **Mitigation**: Incremental testing and performance monitoring
- **Detection**: Continuous performance benchmarking
- **Response**: Optimization and intelligent content selection

## Success Criteria

### Quantitative Goals
- Generate 40+ Rule Cards from 30 secure coding focused cheat sheets
- Maintain 90%+ accuracy compared to manual review sampling
- Keep ingestion time under 10 minutes
- Preserve <2s agent response time with expanded corpus

### Qualitative Goals
- Generated Rule Cards integrate seamlessly with existing system
- OWASP-sourced content is clearly identified in search results
- Scanner integration maintains consistency with manual Rule Cards
- Semantic search provides relevant secure coding guidance

## File Structure After Implementation

```
app/
├── ingestion/                   # NEW: OWASP ingestion pipeline
│   ├── __init__.py
│   ├── owasp_fetcher.py        # OWASP content acquisition
│   ├── content_parser.py       # HTML/Markdown parsing
│   ├── rule_card_generator.py  # OWASP -> Rule Card conversion
│   ├── scanner_mapper.py       # Scanner rule mapping
│   ├── quality_validator.py    # Content quality validation
│   └── ingestion_pipeline.py   # Pipeline orchestration
├── rule_cards/owasp/           # NEW: Generated OWASP Rule Cards
│   ├── input_validation/       # Input validation cheat sheets
│   ├── injection_prevention/   # SQL injection, XSS prevention
│   ├── authentication/         # Auth and session management
│   ├── cryptography/          # Cryptographic practices
│   ├── language_specific/     # Java, Python, .NET, etc.
│   └── framework_specific/    # Spring, Django, React, etc.
└── semantic/                   # MODIFIED: Enhanced corpus
    └── corpus_manager.py       # OWASP content integration

tests/
└── ingestion/                  # NEW: Ingestion test suite
    ├── test_owasp_fetcher.py
    ├── test_content_parser.py
    ├── test_rule_card_generator.py
    ├── test_scanner_mapper.py
    ├── test_quality_validator.py
    └── test_complete_integration.py
```

## ChatGPT API Cost Estimation

### Processing Requirements
- **30 cheat sheets** × **~3,000 tokens per sheet** = **90,000 input tokens**
- **Expected output**: 40-50 Rule Cards × **~800 tokens per card** = **36,000 output tokens**
- **Total processing**: ~126,000 tokens

### Cost Analysis (as of 2024)
**GPT-4 Pricing:**
- Input: $30/1M tokens → **90K tokens = $2.70**
- Output: $60/1M tokens → **36K tokens = $2.16**
- **Total GPT-4 cost: ~$4.86**

**GPT-3.5-turbo Pricing:**
- Input: $1.50/1M tokens → **90K tokens = $0.135**
- Output: $2/1M tokens → **36K tokens = $0.072**
- **Total GPT-3.5-turbo cost: ~$0.21**

### Recommendations
- **Development/Testing**: Use GPT-3.5-turbo for cost efficiency
- **Production Quality**: Use GPT-4 for higher accuracy and better YAML structure adherence
- **Budget-friendly**: Total cost under $5 for complete 30-sheet processing

---

This GitHub-ChatGPT approach provides automated, cost-effective generation of 40-50 high-quality Rule Cards from authoritative OWASP secure coding guidance while maintaining full system integration.