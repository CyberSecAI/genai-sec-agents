# Story 2.5: OWASP Cheat Sheet Ingestion - Implementation Plan

## Plan Overview
**Story ID:** 2.5  
**Focus:** Secure Coding OWASP Cheat Sheets Only  
**Estimated Effort:** 8 story points (reduced from 13 due to focused scope)  
**Target:** 40+ Rule Cards from secure coding focused cheat sheets  

## Secure Coding OWASP Cheat Sheet Scope

### Priority 1: Core Secure Coding (15 cheat sheets)
- **Input Validation Cheat Sheet** - Core secure coding practice
- **SQL Injection Prevention Cheat Sheet** - Critical vulnerability prevention
- **Cross Site Scripting Prevention Cheat Sheet** - XSS mitigation
- **Cross-Site Request Forgery Prevention Cheat Sheet** - CSRF protection
- **Authentication Cheat Sheet** - Secure authentication patterns
- **Session Management Cheat Sheet** - Session security
- **Cryptographic Storage Cheat Sheet** - Data protection
- **Error Handling Cheat Sheet** - Information disclosure prevention
- **Logging Cheat Sheet** - Security logging practices
- **File Upload Cheat Sheet** - File handling security
- **HTTP Headers Cheat Sheet** - Security headers implementation
- **Content Security Policy Cheat Sheet** - CSP configuration
- **Clickjacking Defense Cheat Sheet** - UI security
- **DOM based XSS Prevention Cheat Sheet** - Client-side security
- **Unvalidated Redirects and Forwards Cheat Sheet** - Redirect security

### Priority 2: Language-Specific Secure Coding (8 cheat sheets)
- **Java Security Cheat Sheet** - Java secure coding
- **.NET Security Cheat Sheet** - .NET secure practices
- **Python Security Cheat Sheet** - Python secure coding
- **Node.js Security Cheat Sheet** - Node.js security
- **C# (.NET) Security Cheat Sheet** - C# specific practices
- **PHP Security Cheat Sheet** - PHP secure coding
- **Ruby Security Cheat Sheet** - Ruby secure practices
- **Go Security Cheat Sheet** - Go language security

### Priority 3: Framework-Specific Secure Coding (7 cheat sheets)
- **Spring Security Cheat Sheet** - Spring framework security
- **Django Security Cheat Sheet** - Django secure practices
- **React Security Cheat Sheet** - React application security
- **Angular Security Cheat Sheet** - Angular security patterns
- **Vue.js Security Cheat Sheet** - Vue.js security
- **Express.js Security Cheat Sheet** - Express security
- **Laravel Security Cheat Sheet** - Laravel secure coding

**Total Target: 30 cheat sheets → ~40-50 Rule Cards**

## Technical Implementation Plan

### Task 1: OWASP Content Acquisition and Parsing
**Duration:** 2 days  

#### 1.1 Content Fetcher Implementation
```python
# app/ingestion/owasp_fetcher.py
class OWASPFetcher:
    SECURE_CODING_CHEATSHEETS = {
        'input-validation': 'https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html',
        'sql-injection': 'https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html',
        'xss-prevention': 'https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html',
        # ... additional secure coding focused URLs
    }
    
    def fetch_secure_coding_cheatsheets(self) -> Dict[str, str]:
        """Fetch only secure coding related cheat sheets"""
        
    def cache_content(self, content: str, sheet_id: str) -> str:
        """Cache with SHA256 integrity validation"""
        
    def check_for_updates(self, sheet_id: str) -> bool:
        """Version tracking for content changes"""
```

#### 1.2 Content Parser Implementation
```python
# app/ingestion/content_parser.py
class SecureCodingParser:
    def parse_cheatsheet_sections(self, html_content: str) -> List[ContentSection]:
        """Extract structured sections from OWASP HTML"""
        
    def extract_code_examples(self, section: ContentSection) -> List[CodeExample]:
        """Extract secure/insecure code examples"""
        
    def identify_actionable_requirements(self, content: str) -> List[SecurityRequirement]:
        """Parse content for actionable security requirements"""
```

**Validation Commands:**
```bash
python3 -c "from app.ingestion import OWASPFetcher; f = OWASPFetcher(); print(len(f.fetch_secure_coding_cheatsheets()))"
python3 -m pytest tests/ingestion/test_owasp_fetcher.py -v
```

### Task 2: Content Normalization and Rule Card Generation
**Duration:** 3 days

#### 2.1 Rule Card Generator
```python
# app/ingestion/rule_card_generator.py
class SecureCodingRuleCardGenerator:
    def generate_rule_cards_from_section(self, section: ContentSection) -> List[RuleCard]:
        """Convert OWASP section to multiple Rule Cards"""
        
    def normalize_severity_mapping(self, owasp_content: str) -> SeverityLevel:
        """Map OWASP guidance to our severity levels"""
        
    def extract_dos_and_donts(self, content: str) -> Tuple[List[str], List[str]]:
        """Extract actionable do/don't guidance"""
        
    def generate_yaml_output(self, rule_card: RuleCard) -> str:
        """Generate valid Rule Card YAML"""
```

#### 2.2 Rule Card Schema Compliance
```yaml
# Example generated Rule Card from Input Validation cheat sheet
id: INPUT-VALIDATION-WHITELIST-001
title: "Use allowlist validation for user input"
severity: high
scope: web-application
requirement: "All user input must be validated against a predefined allowlist of acceptable values"
do:
  - "Define explicit allowlists for expected input values"
  - "Validate input length, format, and content"
  - "Reject any input not matching allowlist criteria"
dont:
  - "Rely solely on blacklist validation approaches"
  - "Trust user input without validation"
  - "Use regex alone for complex validation scenarios"
detect:
  semgrep:
    - "owasp.input-validation.missing-whitelist"
  custom:
    - "Check for raw user input usage without validation"
verify:
  tests:
    - "Input validation unit tests with edge cases"
    - "Penetration testing of input endpoints"
refs:
  cwe:
    - "CWE-20"
  owasp:
    - "A03:2021-Injection"
  source:
    - "OWASP Input Validation Cheat Sheet"
```

**Validation Commands:**
```bash
python3 -c "from app.ingestion import SecureCodingRuleCardGenerator; g = SecureCodingRuleCardGenerator(); print(g.validate_generated_cards())"
python3 app/tools/validate_cards.py app/rule_cards/owasp/
```

### Task 3: Scanner Integration Mapping
**Duration:** 2 days

#### 3.1 Scanner Rule Mapping
```python
# app/ingestion/scanner_mapper.py
class SecurityScannerMapper:
    SEMGREP_RULES_DB = {
        'input-validation': ['python.django.security.audit.avoid-unsafe-deserialization',
                           'python.flask.security.audit.direct-use-of-jinja2'],
        'sql-injection': ['python.sqlalchemy.security.audit.sqlalchemy-execute-raw-query',
                         'python.django.security.injection.sql.django-sql-injection'],
    }
    
    def map_owasp_to_semgrep(self, rule_card: RuleCard) -> List[str]:
        """Map Rule Card to existing Semgrep rules"""
        
    def create_custom_semgrep_rule(self, rule_card: RuleCard) -> str:
        """Generate custom Semgrep rule when no existing match"""
        
    def validate_scanner_integration(self, rule_card: RuleCard) -> bool:
        """Ensure scanner rules actually detect the vulnerability"""
```

**Validation Commands:**
```bash
semgrep --config=auto tests/sample_vulnerable_code/
python3 -m pytest tests/ingestion/test_scanner_mapping.py -v
```

### Task 4: Corpus Integration and Semantic Enhancement
**Duration:** 1 day

#### 4.1 Semantic Search Integration
```python
# Modify app/semantic/corpus_manager.py
class CorpusManager:
    def integrate_owasp_rule_cards(self, owasp_cards: List[RuleCard]) -> None:
        """Add OWASP Rule Cards to semantic search corpus"""
        
    def tag_owasp_provenance(self, content: str, source_sheet: str) -> str:
        """Tag content with OWASP source for provenance tracking"""
        
    def maintain_corpus_size_limit(self, max_size_mb: int = 100) -> None:
        """Ensure corpus stays under size limit"""
```

**Validation Commands:**
```bash
python3 -c "from app.semantic import CorpusManager; cm = CorpusManager(); print(f'Corpus size: {cm.get_corpus_size_mb()}MB')"
python3 -c "from app.semantic import SemanticSearchInterface; si = SemanticSearchInterface(); results = si.search_query('input validation'); print(f'Results: {len(results.matches)}')"
```

### Task 5: Ingestion Pipeline and Automation
**Duration:** 1 day

#### 5.1 Pipeline Orchestration
```python
# app/ingestion/ingestion_pipeline.py
class SecureCodingIngestionPipeline:
    def run_full_ingestion(self) -> IngestionReport:
        """Execute complete secure coding cheat sheet ingestion"""
        
    def validate_pipeline_output(self, generated_cards: List[RuleCard]) -> ValidationReport:
        """Comprehensive validation of generated Rule Cards"""
        
    def generate_ingestion_report(self, results: IngestionResults) -> str:
        """Generate detailed report of ingestion process"""
```

**Pipeline Execution:**
```bash
python3 -m app.ingestion.ingestion_pipeline --mode=secure-coding-only --validate
```

### Task 6: Quality Assurance and Validation
**Duration:** 1 day

#### 6.1 Quality Metrics
```python
# app/ingestion/quality_validator.py
class QualityValidator:
    def measure_content_coverage(self, original_cheatsheet: str, generated_cards: List[RuleCard]) -> float:
        """Measure % of actionable content captured"""
        
    def validate_rule_card_accuracy(self, card: RuleCard, source_content: str) -> float:
        """Validate accuracy against source content"""
        
    def check_schema_compliance(self, cards: List[RuleCard]) -> List[ValidationError]:
        """Ensure all generated cards follow schema"""
```

**Quality Validation:**
```bash
python3 -c "from app.ingestion import QualityValidator; qv = QualityValidator(); report = qv.validate_all_generated_cards(); print(f'Quality Score: {report.overall_score}')"
```

## Integration Testing Strategy

### End-to-End Integration Test
```python
# tests/ingestion/test_complete_secure_coding_ingestion.py
def test_complete_secure_coding_pipeline():
    """Test full pipeline from OWASP fetch to semantic search integration"""
    
    # 1. Fetch secure coding cheat sheets
    fetcher = OWASPFetcher()
    content = fetcher.fetch_secure_coding_cheatsheets()
    assert len(content) >= 15  # Minimum priority 1 cheat sheets
    
    # 2. Generate Rule Cards
    generator = SecureCodingRuleCardGenerator()
    rule_cards = generator.process_all_content(content)
    assert len(rule_cards) >= 40  # Target rule card count
    
    # 3. Validate schema compliance
    for card in rule_cards:
        assert validate_rule_card_schema(card)
    
    # 4. Test scanner integration
    mapper = SecurityScannerMapper()
    for card in rule_cards:
        scanner_rules = mapper.get_scanner_rules(card)
        assert len(scanner_rules) > 0
    
    # 5. Test semantic search integration
    corpus_manager = CorpusManager()
    corpus_manager.integrate_owasp_rule_cards(rule_cards)
    
    search_interface = SemanticSearchInterface()
    results = search_interface.search_query("input validation secure coding")
    assert len(results.matches) > 0
    assert any("OWASP" in match.source for match in results.matches)
    
    # 6. Performance validation
    assert corpus_manager.get_corpus_size_mb() < 100
    
    start_time = time.time()
    results = search_interface.search_query("SQL injection prevention")
    search_time = time.time() - start_time
    assert search_time < 1.0  # NFR1 requirement
```

## Performance Requirements Validation

### Load Testing
```bash
# Test with generated Rule Cards
python3 app/claude_code/analyze_context.py test_file.py --semantic
# Should complete in <2s even with expanded corpus

# Test ingestion performance
time python3 -m app.ingestion.ingestion_pipeline --mode=secure-coding-only
# Should complete in <10 minutes
```

## Risk Mitigation

### High Risk: OWASP Content Format Changes
- **Mitigation**: Robust parsing with fallback mechanisms
- **Detection**: Automated testing with known cheat sheet samples
- **Response**: Parser updates and regression testing

### Medium Risk: Generated Rule Card Quality
- **Mitigation**: Manual review sampling and quality metrics
- **Detection**: Accuracy validation against source content
- **Response**: Generator refinement and validation enhancement

### Low Risk: Performance Impact
- **Mitigation**: Incremental testing and performance monitoring
- **Detection**: Continuous performance benchmarking
- **Response**: Optimization and intelligent content selection

## Success Criteria

### Quantitative Goals
- Generate 40+ Rule Cards from 30 secure coding focused cheat sheets
- Maintain 90%+ accuracy compared to manual review sampling
- Keep ingestion time under 10 minutes
- Preserve <2s agent response time with expanded corpus

### Qualitative Goals
- Generated Rule Cards integrate seamlessly with existing system
- OWASP-sourced content is clearly identified in search results
- Scanner integration maintains consistency with manual Rule Cards
- Semantic search provides relevant secure coding guidance

## File Structure After Implementation

```
app/
├── ingestion/                   # NEW: OWASP ingestion pipeline
│   ├── __init__.py
│   ├── owasp_fetcher.py        # OWASP content acquisition
│   ├── content_parser.py       # HTML/Markdown parsing
│   ├── rule_card_generator.py  # OWASP -> Rule Card conversion
│   ├── scanner_mapper.py       # Scanner rule mapping
│   ├── quality_validator.py    # Content quality validation
│   └── ingestion_pipeline.py   # Pipeline orchestration
├── rule_cards/owasp/           # NEW: Generated OWASP Rule Cards
│   ├── input_validation/       # Input validation cheat sheets
│   ├── injection_prevention/   # SQL injection, XSS prevention
│   ├── authentication/         # Auth and session management
│   ├── cryptography/          # Cryptographic practices
│   ├── language_specific/     # Java, Python, .NET, etc.
│   └── framework_specific/    # Spring, Django, React, etc.
└── semantic/                   # MODIFIED: Enhanced corpus
    └── corpus_manager.py       # OWASP content integration

tests/
└── ingestion/                  # NEW: Ingestion test suite
    ├── test_owasp_fetcher.py
    ├── test_content_parser.py
    ├── test_rule_card_generator.py
    ├── test_scanner_mapper.py
    ├── test_quality_validator.py
    └── test_complete_integration.py
```

This focused plan targets secure coding practices specifically, generating approximately 40-50 Rule Cards from the most relevant OWASP cheat sheets while maintaining system performance and integration with existing components.