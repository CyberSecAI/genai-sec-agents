# Epic 1.3 Implementation Plan: Implement the Agent Compiler Toolchain

## Overview

This plan implements the Policy-as-Code compilation system that transforms YAML Rule Cards into machine-readable JSON agent packages. The system will enable deterministic, versioned agent knowledge packages for GenAI security guidance systems.

## Pre-Implementation Checklist

### Prerequisites Verification
- [x] Story 1.2 completed with 15 Rule Cards across 5 domains
- [x] Rule Card YAML schema established and validated
- [x] Project structure exists with app/tools/ and app/rule_cards/ directories
- [x] Python 3.11+ environment available
- [x] Git repository for version control and source digest generation

### Tool Requirements
- [x] Python 3.11+ with pip package management
- [x] PyYAML library for secure YAML processing
- [x] jsonschema library for JSON validation
- [x] pathlib for secure file operations
- [x] hashlib for source digest generation

### Access Requirements
- [x] Write access to app/tools/ for compiler script
- [x] Write access to app/dist/ for compiled output
- [x] Read access to app/rule_cards/ for source Rule Cards
- [x] Git repository access for version and digest generation

### Architecture Dependencies
- [x] Rule Card schema from Story 1.1 (validate_cards.py)
- [x] Rule Cards from Story 1.2 (15 cards across 5 domains)
- [x] Project structure from unified-project-structure.md
- [x] Technology stack requirements (Python 3.11+, PyYAML, jsonschema)

### Security Considerations
- [x] yaml.safe_load() required for YAML deserialization security
- [x] Input validation needed for all manifest and Rule Card inputs
- [x] Path traversal prevention for file operations
- [x] Information disclosure prevention in error messages
- [x] Secure temporary file handling during compilation

## Implementation Steps

### Phase 1: Agent Manifest Schema and File Creation (Estimated: 45 minutes)

#### Step 1.1: Design Agent Manifest Schema
Create YAML schema for agents_manifest.yml defining:
```yaml
agents:
  - name: "secrets-specialist"
    description: "Hardcoded secrets detection and remediation"
    rule_cards:
      - "secrets/*.yml"
    output_file: "secrets-agent.json"
  - name: "web-security-specialist"  
    description: "Web application security (cookies, JWT)"
    rule_cards:
      - "cookies/*.yml"
      - "jwt/*.yml"
    output_file: "web-security-agent.json"
```

#### Step 1.2: Create Initial Agent Manifest
Based on Rule Cards from Story 1.2:
- secrets-specialist: secrets/ domain
- web-security-specialist: cookies/ and jwt/ domains  
- genai-security-specialist: genai/ domain
- container-specialist: docker/ domain

#### Step 1.3: Validate Manifest Structure
Test manifest against existing Rule Card structure from app/rule_cards/

### Phase 2: Core Compiler Infrastructure (Estimated: 90 minutes)

#### Step 2.1: Create compile_agents.py CLI Framework
```python
#!/usr/bin/env python3
import argparse
import yaml
import json
from pathlib import Path

def main():
    parser = argparse.ArgumentParser(description='Compile Rule Cards into agent packages')
    parser.add_argument('--manifest', default='app/tools/agents_manifest.yml')
    parser.add_argument('--rule-cards', default='app/rule_cards/')
    parser.add_argument('--output', default='app/dist/agents/')
    args = parser.parse_args()
```

#### Step 2.2: Implement Secure YAML Loading
Use yaml.safe_load() exclusively:
```python
def load_rule_card(file_path):
    try:
        with open(file_path, 'r') as f:
            return yaml.safe_load(f)  # Security: prevent code execution
    except yaml.YAMLError as e:
        raise ValueError(f"Invalid YAML in {file_path}: {e}")
```

#### Step 2.3: Add JSON Schema Validation  
Implement output validation against Rule Card TypeScript interface

#### Step 2.4: Create Error Handling Framework
Comprehensive error handling without information disclosure

### Phase 3: Metadata Generation System (Estimated: 60 minutes)

#### Step 3.1: Implement Version Generation
```python
def generate_version():
    # Git commit hash + timestamp
    import subprocess
    commit = subprocess.check_output(['git', 'rev-parse', 'HEAD']).decode().strip()
    return f"{commit[:8]}-{int(time.time())}"
```

#### Step 3.2: Add Build Date and Source Digest
- Build timestamp in ISO format
- SHA256 digest of all source Rule Card files
- Git repository information

#### Step 3.3: Include Attribution Notices
Load and include content from docs/ATTRIBUTION.md

#### Step 3.4: Add Source Traceability
Map compiled rules back to original YAML file paths

### Phase 4: Validation Hooks Aggregation (Estimated: 75 minutes)

#### Step 4.1: Parse Detect Metadata
Extract detect sections from all Rule Cards:
```python
def aggregate_validation_hooks(rule_cards):
    hooks = {'semgrep': [], 'trufflehog': [], 'codeql': []}
    for card in rule_cards:
        for tool, rules in card.get('detect', {}).items():
            if tool in hooks:
                hooks[tool].extend(rules)
    return hooks
```

#### Step 4.2: Implement Conflict Resolution
Handle overlapping scanner rules and deduplication

#### Step 4.3: Generate Consolidated Detection Config
Create unified configuration for CI/CD integration

#### Step 4.4: Validate Scanner Rule References
Where possible, verify scanner rules exist and are current

### Phase 5: Output Generation and Packaging (Estimated: 45 minutes)

#### Step 5.1: Create Output Directory Structure
Implement app/dist/agents/ with proper permissions

#### Step 5.2: Generate JSON Packages
Transform Rule Cards to JSON following TypeScript interface:
```json
{
  "agent": {
    "name": "secrets-specialist",
    "version": "abc12345-1693234567",
    "build_date": "2025-08-29T12:00:00Z",
    "source_digest": "sha256:...",
    "attribution": "..."
  },
  "rules": [...],
  "validation_hooks": {...}
}
```

#### Step 5.3: Implement JSON Schema Validation
Validate all output against defined schema

#### Step 5.4: Add Package Integrity Checks
Generate checksums for compiled packages

### Phase 6: Testing and Integration (Estimated: 60 minutes)

#### Step 6.1: Create Comprehensive Test Suite
- Unit tests for each compiler component
- Integration tests for end-to-end compilation
- Security tests for YAML deserialization attacks
- Schema validation tests

#### Step 6.2: Test with Actual Rule Cards
Run compilation against 15 Rule Cards from Story 1.2

#### Step 6.3: Update Build System
Add compilation targets to Makefile

#### Step 6.4: Create Usage Documentation
Command-line interface documentation and examples

## Success Criteria

✅ **AC 1**: agents_manifest.yml created defining sub-agents and Rule Card associations  
✅ **AC 2**: compile_agents.py script reads manifest and Rule Cards successfully  
✅ **AC 3**: Script compiles rules into valid JSON packages per schema  
✅ **AC 4**: Output JSON includes all required metadata (version, build date, source digest, attribution)  
✅ **AC 5**: Script aggregates detect hooks into unified validation_hooks map

## Verification Steps

### Functional Testing
1. **Manifest Loading**: Verify agents_manifest.yml loads correctly with all agent definitions
2. **Rule Card Processing**: Confirm all 15 Rule Cards from Story 1.2 compile successfully
3. **JSON Generation**: Validate output JSON packages follow correct schema structure
4. **Metadata Inclusion**: Check version, build_date, source_digest, and attribution in output
5. **Validation Hooks**: Verify detect metadata aggregates correctly into validation_hooks map

### Integration Testing  
1. **End-to-End Compilation**: Run complete compilation workflow from manifest to JSON packages
2. **Multiple Agent Generation**: Verify manifest with multiple agents generates separate packages
3. **File System Integration**: Confirm proper directory creation and file permissions
4. **Git Integration**: Test version generation and source digest calculation
5. **Build System Integration**: Verify Makefile targets work correctly

### Security Validation
1. **YAML Security**: Test yaml.safe_load() prevents code execution with malicious YAML
2. **Path Traversal Prevention**: Verify file operations don't allow directory traversal
3. **Input Validation**: Test manifest and Rule Card validation prevents injection
4. **Information Disclosure**: Confirm error messages don't expose sensitive information
5. **File Security**: Verify secure temporary file handling and cleanup

### Manual Verification
1. **CLI Usability**: Test command-line interface with various arguments and options
2. **Output Quality**: Manually inspect generated JSON for completeness and accuracy
3. **Documentation**: Verify usage documentation is clear and comprehensive
4. **Error Handling**: Test various error conditions and verify graceful handling

## Time Estimation

**Total Estimated Time**: 5.5 hours

**Phase Breakdown**:
- Phase 1 (Manifest): 45 minutes
- Phase 2 (Core Infrastructure): 90 minutes  
- Phase 3 (Metadata): 60 minutes
- Phase 4 (Validation Hooks): 75 minutes
- Phase 5 (Output Generation): 45 minutes
- Phase 6 (Testing): 60 minutes

**Critical Path**: Phases 1→2→4→5 (core compilation workflow)

**Dependencies**: Story 1.2 completion (✅ done)

**Buffer Time**: 30 minutes for unexpected issues and debugging

## Risk Mitigation

### Technical Risks
**Risk**: YAML deserialization vulnerabilities  
**Mitigation**: Use yaml.safe_load() exclusively, comprehensive security testing

**Risk**: JSON schema compatibility issues  
**Mitigation**: Implement schema validation with jsonschema library, test with actual data

**Risk**: File system security vulnerabilities  
**Mitigation**: Use pathlib for secure path operations, validate all file paths

**Risk**: Performance issues with large Rule Card sets  
**Mitigation**: Implement efficient loading patterns, add performance monitoring

### Dependency Risks
**Risk**: Missing Python libraries  
**Mitigation**: Update requirements.txt, verify environment setup

**Risk**: Git repository access issues  
**Mitigation**: Test Git operations early, provide fallback versioning

### Resource Constraints  
**Risk**: Limited development time  
**Mitigation**: Focus on MVP functionality first, defer advanced features

**Risk**: Complex schema requirements  
**Mitigation**: Start with simple schema, iterate based on testing

### Timeline Risks
**Risk**: Underestimated complexity  
**Mitigation**: 30-minute buffer time, modular implementation approach

**Risk**: Testing reveals major issues  
**Mitigation**: Comprehensive unit testing throughout development

### Rollback Plans
- If compilation fails: Revert to manual JSON generation
- If schema issues arise: Simplify output format temporarily
- If security issues found: Implement additional validation layers

## Next Steps

After Story 1.3 completion:

### Follow-up Stories
- **Story 1.4**: CI/CD integration for automated compilation
- **Story 1.5**: Agent package distribution and versioning
- **Epic 2.1**: IDE integration for real-time security guidance

### Integration Points
- **BMad Agent Framework**: Compiled packages will integrate with web-bundles/agents/
- **Security Toolchain**: validation_hooks will integrate with ci/ directory scanners
- **Documentation System**: Generated packages will reference docs/ for guidance

### Monitoring Requirements
- **Compilation Metrics**: Track build success rates and performance
- **Package Usage**: Monitor agent package consumption patterns
- **Error Tracking**: Log compilation failures and schema violations

### Documentation Updates
- Update main README.md with compiler usage instructions
- Create developer documentation for extending the compiler
- Add troubleshooting guide for common compilation issues

## Implementation Notes

### Security-First Development
- Apply secure coding practices throughout implementation
- Use defensive programming patterns for all file operations
- Implement comprehensive input validation at every boundary
- Follow principle of least privilege for file system access

### Code Quality Standards
- Use Python 3.11+ type hints for all functions
- Implement comprehensive error handling with proper logging
- Follow PEP 8 style guidelines consistently
- Add docstrings for all public functions and classes

### Testing Strategy
- Write tests first for critical security components
- Use pytest framework for all testing
- Mock external dependencies (Git, file system) in unit tests
- Implement property-based testing for schema validation