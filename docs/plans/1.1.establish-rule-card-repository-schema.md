# Epic 1.1 Implementation Plan: Establish Rule Card Repository & Schema

## Overview

This plan details the implementation of the foundational Rule Card repository structure and YAML schema validation system. This is the cornerstone of the Policy-as-Code system, creating the single source of truth for security policies. The implementation focuses heavily on security, particularly YAML parsing safety and input validation to prevent injection attacks.

**Key Deliverables:**
- Complete repository directory structure
- Formal YAML schema for Rule Cards with TypeScript interface
- Secure Python validation script (validate_cards.py)
- Core documentation (ATTRIBUTION.md, SECURITY_GUIDE.md)

## Pre-Implementation Checklist

### Prerequisites Verification
- [ ] **Python Environment**: Confirm Python 3.11+ is available
- [ ] **Repository Access**: Working in genai-sec-agents repository root
- [ ] **Development Tools**: pip, text editor available
- [ ] **Security Context**: Security guidelines loaded and understood

### Tool/Environment Requirements
- [ ] **Python 3.11+** - Primary language per tech stack
- [ ] **PyYAML** - For secure YAML parsing (will be added to requirements.txt)
- [ ] **jsonschema** - For schema validation (will be added to requirements.txt)
- [ ] **pytest** - For testing framework
- [ ] **Working directory**: Repository root (/genai-sec-agents/)

### Security Considerations Upfront
- [ ] **YAML Security**: Plan to use yaml.safe_load() exclusively
- [ ] **Input Validation**: Schema must prevent malicious constructs
- [ ] **File Path Security**: Validate file paths to prevent directory traversal
- [ ] **Error Handling**: No sensitive information in error messages

### Architecture Dependencies
- [ ] **Project Structure**: Follow docs/architecture/unified-project-structure.md
- [ ] **Data Model**: Implement Rule Card interface from docs/architecture/data-models.md
- [ ] **Tech Stack**: Use Python 3.11+ per docs/architecture/tech-stack.md

## Implementation Steps

### Phase 1: Repository Structure Creation (Estimated: 30 minutes)

#### Step 1.1: Create Main Directory Structure
```bash
# Create primary directories per unified project structure
mkdir -p app/rule_cards/{docker,jwt/java,authn,shared}
mkdir -p app/tools
mkdir -p app/dist/agents
mkdir -p app/ci/{semgrep-rules,conftest-policies}
mkdir -p app/policy
mkdir -p docs
mkdir -p tests
mkdir -p .github/workflows
```

#### Step 1.2: Create Repository Files
```bash
# Create placeholder files and basic structure
touch app/rule_cards/.gitkeep
touch app/tools/.gitkeep
touch app/dist/agents/.gitkeep
touch app/ci/semgrep-rules/.gitkeep
touch app/ci/conftest-policies/.gitkeep
touch app/policy/thresholds.yml
touch Makefile
touch requirements.txt
touch README.md
```

**Expected Outcome**: Complete directory structure matching architectural specification

### Phase 2: YAML Schema Definition (Estimated: 45 minutes)

#### Step 2.1: Create JSON Schema for Rule Cards
Create `app/tools/rule-card-schema.json`:
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Rule Card Schema",
  "type": "object",
  "required": ["id", "title", "severity", "scope", "requirement", "do", "dont", "detect", "verify", "refs"],
  "properties": {
    "id": {
      "type": "string",
      "pattern": "^[A-Z][A-Z0-9]+-[A-Z0-9]+-[0-9]{3}$",
      "description": "Unique identifier (e.g., DOCKER-USER-001)"
    },
    "title": {
      "type": "string",
      "minLength": 5,
      "maxLength": 100,
      "description": "Concise, descriptive title"
    },
    "severity": {
      "type": "string",
      "enum": ["low", "medium", "high", "critical"]
    },
    "scope": {
      "type": "string",
      "description": "Context where rule applies"
    },
    "requirement": {
      "type": "string",
      "minLength": 10,
      "description": "Normative statement of requirement"
    },
    "do": {
      "type": "array",
      "items": {"type": "string"},
      "minItems": 1
    },
    "dont": {
      "type": "array", 
      "items": {"type": "string"},
      "minItems": 1
    },
    "detect": {
      "type": "object",
      "patternProperties": {
        "^[a-z][a-z0-9_]*$": {
          "type": "array",
          "items": {"type": "string"}
        }
      }
    },
    "verify": {
      "type": "object",
      "required": ["tests"],
      "properties": {
        "tests": {
          "type": "array",
          "items": {"type": "string"}
        }
      }
    },
    "refs": {
      "type": "object",
      "patternProperties": {
        "^[a-z][a-z0-9_]*$": {
          "type": "array", 
          "items": {"type": "string"}
        }
      }
    }
  },
  "additionalProperties": false
}
```

#### Step 2.2: Create Example Rule Card
Create `app/rule_cards/docker/DOCKER-USER-001.yml`:
```yaml
id: DOCKER-USER-001
title: "Docker containers must not run as root user"
severity: high
scope: dockerfile
requirement: "Container processes must run under a non-root user account to limit privilege escalation risks."
do:
  - "Use USER directive to specify non-root user"
  - "Create dedicated application user in Dockerfile"
  - "Set appropriate file permissions for non-root user"
dont:
  - "Do not run processes as root (UID 0)"
  - "Do not rely on runtime user switching"
  - "Do not use privileged containers unnecessarily"
detect:
  semgrep:
    - "dockerfile.security.missing-user"
    - "dockerfile.security.user-root"
  hadolint:
    - "DL3002"
verify:
  tests:
    - "Verify USER directive is present and not root"
    - "Test container runs with non-root UID"
    - "Validate file permissions work for specified user"
refs:
  cis:
    - "4.1"
  nist:
    - "CM-2"
  owasp:
    - "A06:2021"
```

**Expected Outcome**: Working JSON schema and example Rule Card

### Phase 3: Secure Validation Script (Estimated: 60 minutes)

#### Step 3.1: Create Requirements File
Add to `requirements.txt`:
```
PyYAML>=6.0
jsonschema>=4.0.0
pytest>=7.0.0
```

#### Step 3.2: Implement validate_cards.py with Security Focus
Create `app/tools/validate_cards.py`:
```python
#!/usr/bin/env python3
"""
Secure Rule Card Validator
Validates YAML Rule Cards against schema with security controls
"""
import argparse
import json
import os
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional
import yaml
import jsonschema
from jsonschema import validate, ValidationError

class SecureRuleCardValidator:
    """Secure validator for Rule Cards with YAML safety controls"""
    
    def __init__(self, schema_path: str):
        self.schema = self._load_schema(schema_path)
        self.validation_errors = []
        self.security_warnings = []
    
    def _load_schema(self, schema_path: str) -> Dict[str, Any]:
        """Load JSON schema with path validation"""
        # Security: Validate file path to prevent directory traversal
        safe_path = os.path.normpath(schema_path)
        if not safe_path.startswith(os.getcwd()):
            raise ValueError(f"Invalid schema path: {schema_path}")
        
        try:
            with open(safe_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (json.JSONDecodeError, FileNotFoundError) as e:
            raise ValueError(f"Failed to load schema: {e}")
    
    def _safe_load_yaml(self, file_path: str) -> Optional[Dict[str, Any]]:
        """Securely load YAML file using safe_load"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                # Security: Use safe_load to prevent code execution
                data = yaml.safe_load(f)
                
                # Security: Validate data type
                if not isinstance(data, dict):
                    self.security_warnings.append(
                        f"{file_path}: YAML root must be object, got {type(data).__name__}"
                    )
                    return None
                
                return data
                
        except yaml.YAMLError as e:
            self.validation_errors.append(f"{file_path}: Invalid YAML - {e}")
            return None
        except (FileNotFoundError, PermissionError, UnicodeDecodeError) as e:
            self.validation_errors.append(f"{file_path}: File error - {e}")
            return None
    
    def validate_rule_card(self, file_path: str) -> bool:
        """Validate single Rule Card file"""
        # Security: Sanitize file path
        safe_path = os.path.normpath(file_path)
        
        # Load YAML safely
        rule_data = self._safe_load_yaml(safe_path)
        if rule_data is None:
            return False
        
        # Validate against schema
        try:
            validate(instance=rule_data, schema=self.schema)
            print(f"‚úÖ {file_path}: Valid Rule Card")
            return True
            
        except ValidationError as e:
            self.validation_errors.append(
                f"{file_path}: Schema validation failed - {e.message}"
            )
            return False
    
    def validate_directory(self, directory: str) -> Dict[str, int]:
        """Validate all YAML files in directory"""
        # Security: Validate directory path
        safe_dir = os.path.normpath(directory)
        if not os.path.isdir(safe_dir):
            raise ValueError(f"Invalid directory: {directory}")
        
        results = {"valid": 0, "invalid": 0, "total": 0}
        
        # Find all .yml and .yaml files
        yaml_files = []
        for ext in ['*.yml', '*.yaml']:
            yaml_files.extend(Path(safe_dir).rglob(ext))
        
        for yaml_file in yaml_files:
            results["total"] += 1
            if self.validate_rule_card(str(yaml_file)):
                results["valid"] += 1
            else:
                results["invalid"] += 1
        
        return results
    
    def print_summary(self, results: Dict[str, int]):
        """Print validation summary"""
        print(f"\nüìä Validation Summary:")
        print(f"   Total files: {results['total']}")
        print(f"   Valid: {results['valid']}")
        print(f"   Invalid: {results['invalid']}")
        
        if self.security_warnings:
            print(f"\n‚ö†Ô∏è  Security Warnings:")
            for warning in self.security_warnings:
                print(f"   {warning}")
        
        if self.validation_errors:
            print(f"\n‚ùå Validation Errors:")
            for error in self.validation_errors:
                print(f"   {error}")

def main():
    parser = argparse.ArgumentParser(description="Validate Rule Card YAML files")
    parser.add_argument("path", help="File or directory to validate")
    parser.add_argument("--schema", default="app/tools/rule-card-schema.json", 
                       help="Path to JSON schema file")
    
    args = parser.parse_args()
    
    try:
        validator = SecureRuleCardValidator(args.schema)
        
        if os.path.isfile(args.path):
            # Validate single file
            is_valid = validator.validate_rule_card(args.path)
            sys.exit(0 if is_valid else 1)
        
        elif os.path.isdir(args.path):
            # Validate directory
            results = validator.validate_directory(args.path)
            validator.print_summary(results)
            sys.exit(0 if results["invalid"] == 0 else 1)
        
        else:
            print(f"‚ùå Path does not exist: {args.path}")
            sys.exit(1)
            
    except Exception as e:
        print(f"‚ùå Fatal error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

**Expected Outcome**: Secure, fully functional validation script

### Phase 4: Documentation Creation (Estimated: 30 minutes)

#### Step 4.1: Create ATTRIBUTION.md
```markdown
# Attribution and Acknowledgments

## Project Information
- **Project**: GenAI Security Agents - Policy-as-Code Engine
- **Repository**: genai-sec-agents
- **License**: [To be determined]

## Rule Card Sources
Rule Cards in this repository are based on:
- Industry security standards and best practices
- OWASP guidelines and recommendations  
- CIS Benchmarks and controls
- NIST Cybersecurity Framework
- ASVS (Application Security Verification Standard)

## Third-Party Components
- **PyYAML**: YAML processing library
- **jsonschema**: JSON Schema validation
- **pytest**: Testing framework

## Contributors
- Lead AppSec Engineer: [Name]
- Development Team: [Names]

## Standards References
This project implements security controls based on recognized industry standards. All Rule Cards include proper attribution to source standards in the `refs` section.
```

#### Step 4.2: Create SECURITY_GUIDE.md
```markdown
# Security Guide for Rule Card Development

## Overview
This guide outlines security practices for developing and maintaining Rule Cards in the Policy-as-Code system.

## Rule Card Security Requirements

### YAML Security
- **Safe Parsing**: Always use `yaml.safe_load()` - never `yaml.load()`
- **Input Validation**: Validate all YAML structures against schema
- **File Path Security**: Sanitize and validate file paths to prevent traversal attacks

### Schema Security
- **Strict Validation**: Rule Cards must pass JSON Schema validation
- **Type Safety**: Enforce strict typing for all fields
- **Content Restrictions**: Prevent executable content in YAML

### Development Security
- **Code Review**: All Rule Cards must be reviewed before merge
- **Testing**: Comprehensive testing including security test cases
- **Access Control**: Repository access follows principle of least privilege

## Security Testing
Run security validation with:
```bash
python app/tools/validate_cards.py app/rule_cards/
```

## Threat Model
- **YAML Injection**: Mitigated by safe_load usage
- **Directory Traversal**: Mitigated by path validation
- **Schema Injection**: Mitigated by strict schema enforcement

## Incident Response
Report security issues to: [security-contact]
```

#### Step 4.3: Update README.md
```markdown
# GenAI Security Agents - Policy-as-Code Engine

A comprehensive Policy-as-Code system for security rule management and AI-powered guidance generation.

## Overview
This repository contains Rule Cards (human-readable security policies) and toolchain for compiling them into machine-readable agent packages.

## Quick Start
1. **Validate Rule Cards**: `python app/tools/validate_cards.py app/rule_cards/`
2. **Create New Rule Card**: Copy example from `app/rule_cards/docker/DOCKER-USER-001.yml`
3. **Run Tests**: `pytest tests/`

## Repository Structure
- `app/rule_cards/` - YAML Rule Cards organized by category
- `app/tools/` - Validation and compilation scripts
- `docs/` - Project documentation  
- `tests/` - Test suites
- `app/dist/` - Compiled agent packages

## Security
See [SECURITY_GUIDE.md](docs/SECURITY_GUIDE.md) for security practices and guidelines.

## Contributing
1. Create Rule Cards following the schema in `app/tools/rule-card-schema.json`
2. Validate with `python app/tools/validate_cards.py`
3. Run full test suite: `pytest`
4. Submit pull request

## License
[To be determined]
```

**Expected Outcome**: Complete documentation set

## Success Criteria

### Acceptance Criteria Mapping
‚úÖ **AC1**: Repository structure created with all required directories
‚úÖ **AC2**: JSON Schema defined with Rule Card interface matching data model
‚úÖ **AC3**: Directory structure follows unified-project-structure.md specification
‚úÖ **AC4**: validate_cards.py script created with secure YAML parsing
‚úÖ **AC5**: ATTRIBUTION.md and SECURITY_GUIDE.md documents created

### Technical Success Indicators
- [ ] All directories created per architecture specification
- [ ] JSON schema validates example Rule Card successfully  
- [ ] validate_cards.py runs without errors on example Rule Card
- [ ] Security controls prevent YAML injection attacks
- [ ] Documentation is complete and professional

## Verification Steps

### Functional Testing
1. **Schema Validation Test**:
   ```bash
   python app/tools/validate_cards.py app/rule_cards/docker/DOCKER-USER-001.yml
   ```
   Expected: ‚úÖ Valid Rule Card message

2. **Directory Structure Verification**:
   ```bash
   ls -la app/rule_cards/ app/tools/ docs/ app/ci/ app/policy/ app/dist/
   ```
   Expected: All directories present with correct structure

3. **Requirements Installation**:
   ```bash
   pip install -r requirements.txt
   ```
   Expected: PyYAML, jsonschema, pytest installed

### Security Validation
1. **YAML Safety Test**:
   - Create malicious YAML file with Python code
   - Run validator against it
   - Expected: Safe parsing, no code execution

2. **Directory Traversal Test**:
   ```bash
   python app/tools/validate_cards.py ../../../etc/passwd
   ```
   Expected: Path validation error, no file access

3. **Schema Injection Test**:
   - Create Rule Card with executable content in fields
   - Run validation
   - Expected: Schema validation failure

### Integration Testing
1. **End-to-End Workflow**:
   - Create new Rule Card
   - Validate with script
   - Confirm passes/fails appropriately

2. **File System Permissions**:
   - Verify read/write access to all required directories
   - Test with restricted permissions

## Time Estimation

### Total Estimated Time: 2.5 - 3 hours

**Critical Path**:
1. Directory structure (30 min)
2. Schema definition (45 min) 
3. Validation script (60 min)
4. Documentation (30 min)
5. Testing and verification (30 min)

**Buffer Time**: 30 minutes for unexpected issues

**Dependencies**: None (this is the foundational story)

## Risk Mitigation

### Technical Risks
- **Risk**: YAML parsing vulnerabilities
  - **Mitigation**: Exclusive use of yaml.safe_load(), comprehensive security testing
- **Risk**: Schema validation bypass
  - **Mitigation**: Strict JSON Schema with additionalProperties: false
- **Risk**: Directory traversal attacks  
  - **Mitigation**: Path normalization and validation

### Timeline Risks
- **Risk**: Complex schema definition taking longer than expected
  - **Mitigation**: Start with minimal schema, iterate
- **Risk**: Security implementation complexity
  - **Mitigation**: Follow established secure coding patterns from loaded guidelines

### Rollback Plans
- **If validation script fails**: Use manual YAML validation temporarily
- **If schema is too restrictive**: Relax non-critical constraints
- **If directory structure conflicts**: Adjust to match existing project needs

## Next Steps

After completion of this story:

1. **Story 1.2**: Manually Ingest and Author Initial Rule Cards
   - Use this schema and validation system
   - Create 10-15 production Rule Cards

2. **Story 1.3**: Implement Agent Compiler Toolchain
   - Read Rule Cards validated by this system
   - Compile into JSON packages

3. **Integration Points**:
   - CI/CD pipeline integration for automatic validation
   - Integration with GitHub Actions for pull request checks

4. **Monitoring Requirements**:
   - Track Rule Card validation success rates
   - Monitor for security issues in YAML processing

5. **Documentation Updates**:
   - Update architecture documentation with implemented structure
   - Create developer onboarding guide