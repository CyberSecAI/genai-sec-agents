# Epic 1.2 Implementation Plan: Manually Ingest and Author Initial Rule Cards

## Overview

This plan details the implementation of Story 1.2, which focuses on manually creating 10-15 Rule Cards covering MVP security domains. The story will establish the foundational knowledge base by researching authoritative sources (OWASP, ASVS, CIS) and creating production-ready Rule Cards for hardcoded secrets, secure cookies, JWT handling, and GenAI development security. Each Rule Card must pass schema validation and include accurate scanner mappings to form the MVP security guidance system.

## Pre-Implementation Checklist

- [ ] **Prerequisites Verification**
  - [ ] Story 1.1 completed with rule_cards/ directory structure in place
  - [ ] validate_cards.py script available and functional from Story 1.1
  - [ ] YAML schema validation system operational
  - [ ] Repository access confirmed with write permissions to rule_cards/ directories

- [ ] **Research Environment Setup**
  - [ ] Access to OWASP Application Security Verification Standard (ASVS) documentation
  - [ ] Access to OWASP Top 10 and OWASP Top 10 for LLMs documentation
  - [ ] Access to CWE (Common Weakness Enumeration) database
  - [ ] Access to Semgrep rule registry and documentation
  - [ ] Access to TruffleHog patterns and CodeQL query documentation
  - [ ] Research tools for scanner rule verification (GitHub repositories, official docs)

- [ ] **Tool Requirements**
  - [ ] Python 3.11+ environment with PyYAML for YAML validation
  - [ ] Text editor with YAML syntax highlighting and validation
  - [ ] Git access for version control and collaboration
  - [ ] Web browser for research and documentation access

- [ ] **Architecture Dependencies**
  - [ ] Understanding of Rule Card data model from architecture/data-models.md
  - [ ] Knowledge of directory structure from architecture/unified-project-structure.md
  - [ ] Familiarity with target scanner tools (Semgrep, TruffleHog, CodeQL, Hadolint)

- [ ] **Security Considerations**
  - [ ] Understanding of threat model for Rule Card content security
  - [ ] Knowledge of YAML deserialization attack prevention measures
  - [ ] Awareness of information disclosure risks in documentation
  - [ ] Understanding of peer review process for security content validation

## Implementation Steps

### Phase 1: Research Foundation and Setup (Estimated: 4 hours)

#### Step 1.1: Security Standards Research (90 minutes)
1. **ASVS Research**: Study relevant ASVS sections:
   - V3.1-V3.3 (Session Management) for JWT handling
   - V3.4 (Cookie-based Session Management) for secure cookies
   - V14.2 (Configuration) for hardcoded secrets
2. **CWE Research**: Identify relevant weakness patterns:
   - CWE-798 (Use of Hard-coded Credentials)
   - CWE-614 (Sensitive Cookie in HTTPS Session Without 'Secure' Attribute)
   - CWE-1004 (Sensitive Cookie Without 'HttpOnly' Flag)
   - CWE-287 (Improper Authentication)
   - CWE-347 (Improper Verification of Cryptographic Signature)
3. **OWASP Research**: Review current threat landscapes:
   - OWASP Top 10 2021 for general security principles
   - OWASP Top 10 for LLMs for GenAI security considerations

#### Step 1.2: Scanner Tool Research (90 minutes)
1. **Semgrep Rules Research**:
   ```bash
   # Research existing Semgrep rules for target domains
   curl -s https://api.semgrep.dev/v1/rules | grep -E "(jwt|cookie|secret|hardcoded)"
   ```
2. **TruffleHog Patterns**: Study regex patterns for secret detection
3. **CodeQL Queries**: Research available security queries for cookie and JWT handling
4. **Documentation Verification**: Ensure all referenced scanner rules are current and accessible

#### Step 1.3: Rule Card Structure Preparation (60 minutes)
1. **Template Creation**: Create base YAML template with all required fields
2. **ID Naming Convention**: Establish consistent naming pattern (DOMAIN-TOPIC-NNN)
3. **Directory Organization**: Plan Rule Card placement in appropriate directories:
   ```
   rule_cards/
   ├── secrets/         # Hardcoded secrets Rule Cards
   ├── jwt/java/        # JWT handling Rule Cards
   ├── authn/          # Cookie authentication Rule Cards
   └── genai/          # GenAI security Rule Cards
   ```

### Phase 2: Hardcoded Secrets Rule Cards Creation (Estimated: 5 hours)

#### Step 2.1: API Keys Detection Rule Card (75 minutes)
```yaml
# Template structure for SECRETS-API-001
id: SECRETS-API-001
title: "Detect Hardcoded API Keys in Source Code"
severity: high
scope: "backend:all"
requirement: "API keys must not be embedded directly in source code"
do: 
  - "Store API keys in environment variables or secure key management systems"
  - "Use configuration files that are excluded from version control"
  - "Implement runtime key retrieval from secure storage"
dont:
  - "Hardcode API keys directly in source code"
  - "Commit API keys to version control systems"
  - "Store API keys in configuration files tracked by Git"
detect:
  semgrep: ["generic.secrets.security.detected-generic-secret.detected-generic-secret"]
  truffleHog: ["api-key-patterns"]
verify:
  tests:
    - "Run static analysis tools to scan for hardcoded API keys"
    - "Verify environment variable usage for key retrieval"
    - "Confirm no keys present in Git history"
refs:
  asvs: ["V14.2.1"]
  cwe: ["CWE-798"]
```

#### Step 2.2: Database Credentials Rule Card (75 minutes)
- Research database credential detection patterns
- Create SECRETS-DB-001 with focus on connection strings and passwords
- Map to TruffleHog database-specific patterns
- Include references to ASVS V14.2.2 and CWE-798

#### Step 2.3: JWT Secret Keys Rule Card (75 minutes)
- Research JWT signing key detection in source code
- Create SECRETS-JWT-001 for hardcoded JWT secrets
- Map to Semgrep JWT-specific rules for key detection
- Reference ASVS V3.2.1 and CWE-798

#### Step 2.4: Cloud Credentials Rule Card (75 minutes)
- Research AWS, Azure, GCP credential patterns
- Create SECRETS-CLOUD-001 for cloud access keys
- Map to TruffleHog cloud provider patterns
- Include CWE-798 and relevant cloud security standards

### Phase 3: Secure Cookies Rule Cards Creation (Estimated: 3 hours)

#### Step 3.1: HttpOnly Flag Rule Card (60 minutes)
```yaml
# Template structure for COOKIES-HTTP-001
id: COOKIES-HTTP-001
title: "Enforce HttpOnly Flag on Security-Sensitive Cookies"
severity: medium
scope: "web:all"
requirement: "Security-sensitive cookies must include HttpOnly flag to prevent XSS access"
do:
  - "Set HttpOnly flag on session cookies, authentication tokens, and CSRF tokens"
  - "Configure web framework defaults to include HttpOnly for security cookies"
  - "Review cookie security settings in application configuration"
dont:
  - "Create session cookies without HttpOnly flag"
  - "Allow JavaScript access to authentication cookies"
  - "Use default cookie settings without security review"
detect:
  semgrep: ["javascript.express.security.audit.express-cookie-httponly-false"]
  codeql: ["js/missing-httponly-flag"]
verify:
  tests:
    - "Inspect HTTP responses to verify HttpOnly flag presence"
    - "Test JavaScript cookie access is blocked for security cookies"
    - "Review web framework cookie configuration"
refs:
  asvs: ["V3.4.1"]
  cwe: ["CWE-1004"]
```

#### Step 3.2: Secure Flag Rule Card (60 minutes)
- Create COOKIES-SECURE-001 for HTTPS-only cookie transmission
- Map to Semgrep patterns for missing Secure flag detection
- Reference ASVS V3.4.1 and CWE-614

#### Step 3.3: SameSite Attribute Rule Card (60 minutes)
- Create COOKIES-SAMESITE-001 for CSRF protection
- Research modern SameSite attribute requirements
- Map to CodeQL queries for missing SameSite detection
- Reference ASVS V4.2.2 and modern web security standards

### Phase 4: JWT Handling Rule Cards Creation (Estimated: 4 hours)

#### Step 4.1: JWT Expiration Validation Rule Card (60 minutes)
```yaml
# Template structure for JWT-EXP-001
id: JWT-EXP-001
title: "Validate JWT Token Expiration Claims"
severity: high
scope: "backend:java"
requirement: "JWT tokens must be validated for expiration before processing claims"
do:
  - "Check 'exp' claim against current timestamp before token processing"
  - "Implement automatic token rejection for expired JWTs"
  - "Set appropriate token lifetime based on security requirements"
dont:
  - "Process JWT tokens without expiration validation"
  - "Accept tokens with missing 'exp' claims"
  - "Use excessively long token lifetimes"
detect:
  semgrep: ["java.lang.security.audit.jwt-missing-expiration-check"]
verify:
  tests:
    - "Test token rejection with expired JWT"
    - "Verify expiration claim validation in token processing"
    - "Confirm appropriate error handling for expired tokens"
refs:
  asvs: ["V3.2.1", "V3.2.2"]
  cwe: ["CWE-287"]
```

#### Step 4.2: JWT Signature Verification Rule Card (60 minutes)
- Create JWT-SIG-001 for signature validation requirements
- Research Java JWT library signature verification patterns
- Map to Semgrep rules for missing signature checks
- Reference ASVS V3.2.3 and CWE-347

#### Step 4.3: JWT Algorithm Confusion Prevention Rule Card (60 minutes)
- Create JWT-ALG-001 for algorithm validation
- Research "none" algorithm attack prevention
- Map to specific Java JWT library patterns
- Reference JWT security best practices and CWE-347

#### Step 4.4: JWT Key Management Rule Card (60 minutes)
- Create JWT-KEY-001 for proper key handling
- Research secure key storage and rotation practices
- Map to Semgrep patterns for hardcoded JWT keys
- Reference ASVS V6.2 (Cryptography) and relevant CWEs

### Phase 5: GenAI Development Security Rule Cards Creation (Estimated: 3 hours)

#### Step 5.1: Prompt Injection Prevention Rule Card (60 minutes)
```yaml
# Template structure for GENAI-PROMPT-001
id: GENAI-PROMPT-001
title: "Prevent Prompt Injection in AI Model Interactions"
severity: high
scope: "ai:all"
requirement: "User inputs to AI models must be sanitized to prevent prompt injection attacks"
do:
  - "Implement input validation and sanitization for AI prompts"
  - "Use prompt templates with clear separation of instructions and user data"
  - "Apply output filtering to detect potential injection attempts"
dont:
  - "Directly concatenate user input into AI prompts"
  - "Trust user input without validation in AI contexts"
  - "Ignore potential prompt manipulation in user queries"
detect:
  custom: ["prompt-injection-patterns"]
verify:
  tests:
    - "Test AI responses to crafted injection attempts"
    - "Verify input sanitization prevents prompt manipulation"
    - "Review prompt construction for injection vulnerabilities"
refs:
  owasp-llm: ["LLM01", "LLM02"]
```

#### Step 5.2: AI API Key Security Rule Card (60 minutes)
- Create GENAI-APIKEY-001 for AI service credential management
- Research OpenAI, Anthropic, other AI API security requirements
- Map to existing secret detection patterns
- Reference emerging AI security frameworks

#### Step 5.3: Model Input Sanitization Rule Card (60 minutes)
- Create GENAI-INPUT-001 for AI input validation
- Research current best practices for AI input handling
- Document custom detection patterns for AI-specific vulnerabilities
- Reference OWASP Top 10 for LLMs and emerging standards

### Phase 6: Quality Assurance and Validation (Estimated: 2 hours)

#### Step 6.1: Schema Validation (30 minutes)
```bash
# Run validation against all created Rule Cards
python validate_cards.py rule_cards/secrets/
python validate_cards.py rule_cards/jwt/java/
python validate_cards.py rule_cards/authn/
python validate_cards.py rule_cards/genai/
```

#### Step 6.2: Content Review and Consistency Check (60 minutes)
- Review all Rule Cards for security accuracy
- Verify consistent formatting and structure
- Check that all required fields are properly populated
- Validate external references (ASVS, CWE) are current

#### Step 6.3: Scanner Rule Verification (30 minutes)
- Spot-check Semgrep rules exist and function as expected
- Verify TruffleHog patterns are current
- Validate CodeQL queries are accessible
- Document any custom patterns that need development

### Phase 7: Documentation and Integration (Estimated: 1 hour)

#### Step 7.1: Documentation Creation (30 minutes)
- Update repository README with new Rule Card information
- Document research sources and methodology
- Create examples of Rule Card usage by agents

#### Step 7.2: Integration Verification (30 minutes)
- Verify Rule Cards are properly organized in directory structure
- Test overall repository structure and navigation
- Confirm Git integration and version control

## Success Criteria

✅ **Acceptance Criteria 1**: Minimum 10-15 Rule Cards authored in YAML format and pass schema validation
- [ ] At least 4 hardcoded secrets Rule Cards created and validated
- [ ] At least 3 secure cookies Rule Cards created and validated  
- [ ] At least 4 JWT handling Rule Cards created and validated
- [ ] At least 3 GenAI security Rule Cards created and validated
- [ ] All Rule Cards pass validate_cards.py without errors

✅ **Acceptance Criteria 2**: Initial set covers MVP target domains
- [ ] Hardcoded secrets domain: API keys, database credentials, JWT secrets, cloud credentials
- [ ] Secure cookies domain: HttpOnly, Secure, SameSite attributes
- [ ] JWT handling domain: expiration, signature verification, algorithm validation, key management
- [ ] GenAI development security: prompt injection, input sanitization, API security

✅ **Acceptance Criteria 3**: Accurate detect metadata mapping to real-world scanner rules
- [ ] All Semgrep rule references verified and current
- [ ] TruffleHog patterns mapped to appropriate secret types
- [ ] CodeQL queries validated where applicable
- [ ] Custom detection patterns documented for GenAI security

✅ **Acceptance Criteria 4**: Traceability references to external standards
- [ ] ASVS references accurate and current for all applicable Rule Cards
- [ ] CWE references properly mapped to vulnerability patterns
- [ ] OWASP references included where relevant
- [ ] Emerging standards (OWASP Top 10 for LLMs) referenced for GenAI security

## Verification Steps

### Functional Testing
1. **Schema Validation Testing**
   ```bash
   # Test each domain directory
   python validate_cards.py rule_cards/secrets/ --verbose
   python validate_cards.py rule_cards/jwt/java/ --verbose  
   python validate_cards.py rule_cards/authn/ --verbose
   python validate_cards.py rule_cards/genai/ --verbose
   ```

2. **YAML Parsing Security Testing**
   ```bash
   # Test with safe_load to prevent deserialization attacks
   python -c "import yaml; yaml.safe_load(open('rule_cards/secrets/SECRETS-API-001.yaml'))"
   ```

3. **Rule Card Field Validation**
   - Verify all required fields present: id, title, severity, scope, requirement, do, dont, detect, verify, refs
   - Validate severity values: 'low', 'medium', 'high', 'critical'
   - Check ID format follows DOMAIN-TOPIC-NNN convention
   - Confirm detect metadata structure with proper scanner tool mappings

### Integration Testing
1. **Directory Structure Validation**
   ```bash
   find rule_cards/ -name "*.yaml" | wc -l  # Should be 10-15
   find rule_cards/ -type d                  # Verify directory organization
   ```

2. **Cross-Reference Validation**
   - Manually verify sample ASVS references (e.g., V3.2.1, V14.2.1)
   - Check CWE references against official database
   - Validate OWASP references are current

3. **Repository Integration**
   - Test Git add/commit process for new Rule Cards
   - Verify file permissions and access controls
   - Confirm repository structure integrity

### Security Validation
1. **Content Security Review**
   - Verify no actual secrets, passwords, or sensitive data in Rule Cards
   - Confirm security recommendations align with current best practices
   - Check that Rule Cards don't introduce security vulnerabilities through incorrect guidance

2. **Scanner Rule Verification** (Sample Testing)
   ```bash
   # Test Semgrep rule existence (example)
   semgrep --config=auto --dry-run rule_cards/secrets/SECRETS-API-001.yaml
   ```

3. **Input Validation Testing**
   - Test validate_cards.py with malformed YAML files
   - Verify proper error handling for invalid Rule Card structures
   - Confirm schema validation prevents security bypasses

### Manual Verification
1. **Content Quality Review**
   - Read each Rule Card for clarity and completeness
   - Verify security guidance accuracy against authoritative sources  
   - Check consistency in language, structure, and formatting

2. **Coverage Verification**
   - Confirm all MVP domains are covered as specified
   - Verify Rule Card distribution meets minimum requirements (10-15 total)
   - Check that critical security patterns are addressed

3. **Documentation Review**
   - Verify research sources are documented
   - Check that rationale for each domain is clear
   - Confirm examples and usage guidance are provided

## Time Estimation

### Total Estimated Time: 22 hours

**Phase Breakdown:**
- Phase 1: Research Foundation and Setup - 4 hours
- Phase 2: Hardcoded Secrets Rule Cards - 5 hours
- Phase 3: Secure Cookies Rule Cards - 3 hours
- Phase 4: JWT Handling Rule Cards - 4 hours
- Phase 5: GenAI Development Security Rule Cards - 3 hours
- Phase 6: Quality Assurance and Validation - 2 hours
- Phase 7: Documentation and Integration - 1 hour

**Critical Path Dependencies:**
1. Phase 1 (Research) must be completed before all other phases
2. Phases 2-5 (Rule Card creation) can be partially parallelized but should be sequential for quality control
3. Phase 6 (QA) depends on completion of Phases 2-5
4. Phase 7 (Documentation) depends on all previous phases

**Buffer Time:** 4 hours (20% buffer) for unexpected issues such as:
- Scanner rule research complications
- Schema validation iterations
- Security content accuracy verification
- Integration challenges

**Total with Buffer:** 26 hours

## Risk Mitigation

### Technical Risks and Solutions

**Risk**: Scanner rule references become outdated or invalid
- **Mitigation**: Focus on stable, well-maintained scanner rules from official sources
- **Fallback**: Document custom patterns where official rules are unavailable
- **Verification**: Implement periodic Rule Card maintenance process

**Risk**: Security guidance accuracy concerns
- **Mitigation**: Use only authoritative sources (ASVS, OWASP, CWE) for security requirements
- **Verification**: Implement peer review process for all Rule Card content
- **Documentation**: Clearly cite all sources and reasoning for security recommendations

**Risk**: YAML schema validation failures
- **Mitigation**: Create template with all required fields before bulk creation
- **Testing**: Validate each Rule Card immediately after creation
- **Automation**: Use consistent YAML structure and validation tooling

### Dependency Risks

**Risk**: Story 1.1 validation system not fully operational
- **Assessment**: Verify validate_cards.py functionality before starting Rule Card creation
- **Mitigation**: Fix any validation system issues before proceeding with content creation
- **Fallback**: Manual YAML validation if automated system unavailable

**Risk**: Missing access to research sources
- **Mitigation**: Identify and secure access to all required documentation (ASVS, OWASP, etc.) upfront
- **Fallback**: Use cached/archived versions of standards if live access unavailable
- **Documentation**: Clearly note version and access date for all referenced standards

### Resource Constraints

**Risk**: Time constraints affecting research quality
- **Mitigation**: Prioritize most critical security domains (secrets, JWT) if time becomes limited
- **Quality Gate**: Maintain minimum quality standards even if quantity needs to be reduced
- **Planning**: Build buffer time into estimates for thorough research

**Risk**: Scanner tool access limitations
- **Mitigation**: Focus on publicly available scanner rules and patterns
- **Documentation**: Clearly mark any scanner references that require specific tool access
- **Alternative**: Develop custom detection patterns where commercial tools aren't accessible

### Timeline Risks

**Risk**: Research phase taking longer than estimated
- **Mitigation**: Set hard time boundaries for research and move to creation phase
- **Quality Control**: Focus on most authoritative sources first (ASVS, core OWASP docs)
- **Incremental**: Create Rule Cards incrementally as research is completed

**Risk**: Quality assurance revealing major issues requiring rework
- **Mitigation**: Implement continuous validation during creation phase
- **Early Testing**: Validate Rule Card structure with first few examples
- **Iterative**: Fix issues immediately rather than batching at end

### Rollback Plans

**Risk**: Rule Cards fail security review or cause system issues
- **Plan**: Maintain Git branch isolation until full validation complete
- **Verification**: Complete security review before merging to main branch
- **Documentation**: Clearly document all changes and sources for easy rollback if needed

**Risk**: Schema validation failures prevent integration
- **Plan**: Maintain working backup of validation system from Story 1.1
- **Testing**: Verify schema compatibility before bulk Rule Card creation
- **Recovery**: Ability to revert to previous working state and adjust Rule Card format

## Next Steps

### Follow-up Stories and Epics
1. **Story 1.3**: Automated Rule Card ingestion and processing system
   - Integration points: Rule Card YAML parsing and validation
   - Dependencies: Successful completion of manual Rule Card creation process

2. **Story 2.x**: Agent integration with Rule Card knowledge base
   - Integration points: Rule Card access patterns and query interfaces
   - Dependencies: Validated Rule Card structure and content

3. **Future Security Domains**: Expansion of Rule Card coverage
   - Build on: Established creation methodology and validation process
   - Areas: Container security, API security, additional language-specific patterns

### Integration Points with Other Work
1. **Agent System Integration**
   - Rule Cards will be consumed by AI agents for security guidance
   - Need to establish Rule Card access patterns and usage protocols
   - Integration testing with agent systems will validate Rule Card utility

2. **CI/CD Pipeline Integration**
   - Rule Cards with detect metadata will drive automated security scanning
   - Need to establish scanner integration points and automation workflows
   - Validation of scanner rule accuracy becomes critical for pipeline effectiveness

### Monitoring and Maintenance Requirements
1. **Rule Card Currency Monitoring**
   - Scanner rule references need periodic validation
   - External standard references (ASVS, CWE) need version tracking
   - Establish update schedule for Rule Card maintenance

2. **Usage Analytics**
   - Track which Rule Cards are most frequently accessed by agents
   - Monitor effectiveness of detect metadata in actual scanning workflows
   - Gather feedback on Rule Card clarity and usefulness

3. **Quality Metrics**
   - False positive/negative rates for scanner rule mappings
   - Accuracy of security guidance through usage feedback
   - Completeness of coverage across security domains

### Documentation Updates Needed
1. **Repository Documentation**
   - Update main README with Rule Card usage instructions
   - Document Rule Card creation methodology for future expansion
   - Create contributor guidelines for Rule Card development

2. **Agent Integration Documentation**
   - Document Rule Card consumption patterns for agent developers
   - Create examples of Rule Card usage in agent workflows
   - Establish Rule Card query and retrieval interfaces

3. **Security Documentation**
   - Document security review process for Rule Card content
   - Create threat model for Rule Card system
   - Establish security maintenance procedures

This implementation plan provides a comprehensive roadmap for creating high-quality, security-focused Rule Cards that will form the foundation of the MVP knowledge base while maintaining strict security standards and validation processes throughout the development lifecycle.