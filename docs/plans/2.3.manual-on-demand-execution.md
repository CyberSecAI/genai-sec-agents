# Epic 2.3 Implementation Plan: Manual On-Demand Execution

## Overview
This implementation plan extends the existing Claude Code sub-agent framework (Stories 2.1 and 2.2) to support manual security analysis commands. The manual command will allow developers to trigger comprehensive security scans of individual files or entire workspaces directly from Claude Code, providing pre-commit validation that's consistent with CI/CD pipeline checks.

**Key Value**: Enables developers to proactively identify and fix security issues before committing code, bridging the gap between real-time guidance and automated pipeline validation.

## Pre-Implementation Checklist

### Prerequisites Verification
- [ ] **Story 2.1 Complete**: AgenticRuntime core components available in `app/runtime/`
- [ ] **Story 2.2 Complete**: Claude Code sub-agent framework available in `app/claude_code/`
- [ ] **Compiled Packages**: 5 agent packages available in `app/dist/agents/`
- [ ] **Claude Code Integration**: Sub-agent configuration at `.claude/agents/security-guidance.md`

### Tool/Environment Requirements
- [ ] **Python 3.11+**: Runtime environment with existing dependencies
- [ ] **Claude Code Platform**: Command registration and integration capabilities
- [ ] **File System Access**: Read permissions for workspace traversal
- [ ] **Testing Framework**: pytest for comprehensive test coverage

### Access Requirements
- [ ] **Agent Packages**: Read access to `app/dist/agents/` directory
- [ ] **Runtime Components**: Access to Story 2.1 AgenticRuntime classes
- [ ] **Sub-Agent Framework**: Extension points in Story 2.2 implementation
- [ ] **Claude Code APIs**: Command registration and display interfaces

### Architecture/Design Dependencies
- [ ] **Existing Context Analysis**: `analyze_context.py` provides foundation for extension
- [ ] **Runtime Management**: `SecurityRuntimeManager` handles package loading
- [ ] **Caching System**: Performance optimizations from Story 2.2 available for reuse
- [ ] **Input Sanitization**: Security patterns established in existing implementation

### Security Considerations
- [ ] **Path Traversal Protection**: Must implement secure file system traversal
- [ ] **Input Validation**: All user inputs require sanitization
- [ ] **Resource Limits**: Workspace analysis needs timeout and memory controls
- [ ] **Display Security**: IDE output must be sanitized against injection attacks
- [ ] **CI/CD Consistency**: Manual results must predict pipeline outcomes

## Implementation Steps

### Phase 1: Command Interface Design (Estimated: 45 minutes)
#### Step 1.1: Create Manual Command Module
Create `app/claude_code/manual_commands.py` with command interface:

```python
#!/usr/bin/env python3
"""
Manual Security Analysis Commands for Claude Code

Provides manual command interface for triggering comprehensive security analysis
of files or workspaces directly from Claude Code IDE.
"""

from typing import Dict, List, Any, Optional
from pathlib import Path
from .analyze_context import CodeContextAnalyzer

class ManualSecurityCommands:
    """Handles manual security analysis commands."""
    
    def __init__(self):
        self.analyzer = CodeContextAnalyzer()
        self.analyzer.initialize()
    
    def analyze_file(self, file_path: str, analysis_depth: str = "standard") -> Dict[str, Any]:
        """Analyze a single file for security issues."""
        pass
    
    def analyze_workspace(self, workspace_path: str = None, analysis_depth: str = "standard") -> Dict[str, Any]:
        """Analyze entire workspace for security issues."""
        pass
```

#### Step 1.2: Implement Command Registration
Update `.claude/agents/security-guidance.md` to include manual command:

```markdown
## Available Commands

### *security-scan-file [file_path] [--depth=standard|comprehensive]
Performs security analysis on the specified file.

### *security-scan-workspace [--path=workspace_path] [--depth=standard|comprehensive]  
Performs security analysis on the entire workspace or specified directory.
```

#### Step 1.3: Add Command Parameter Validation
Implement secure parameter handling with path validation:

```python
def _validate_file_path(self, file_path: str) -> Path:
    """Validate and sanitize file path to prevent traversal attacks."""
    # Implementation with allow-list validation
    pass

def _validate_analysis_depth(self, depth: str) -> str:
    """Validate analysis depth parameter."""
    # Implementation with enum validation
    pass
```

### Phase 2: Analysis Engine Extension (Estimated: 90 minutes)
#### Step 2.1: Extend Context Analyzer for Manual Mode
Modify `app/claude_code/analyze_context.py` to support manual analysis:

```python
def analyze_file_manual(self, file_path: str, include_all_rules: bool = True) -> Dict[str, Any]:
    """Analyze file with comprehensive rule set for manual analysis."""
    # Enhanced analysis for manual mode
    pass

def analyze_workspace_manual(self, workspace_path: str, file_filters: List[str] = None) -> Dict[str, Any]:
    """Analyze multiple files in workspace."""
    # Multi-file analysis implementation
    pass
```

#### Step 2.2: Implement Multi-File Analysis
Create workspace traversal with security controls:

```python
def _discover_workspace_files(self, workspace_path: Path, filters: List[str] = None) -> List[Path]:
    """Safely discover files in workspace with security controls."""
    # Secure file discovery with allow-lists
    pass

def _aggregate_analysis_results(self, file_results: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Aggregate results from multiple file analyses."""
    # Result aggregation and deduplication
    pass
```

#### Step 2.3: Add Rule Aggregation Logic
Implement comprehensive rule selection across all agent packages:

```python
def _select_all_applicable_rules(self, context: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Select all applicable rules from all agent packages for manual analysis."""
    # Cross-package rule aggregation
    pass
```

### Phase 3: Results Display System (Estimated: 60 minutes)  
#### Step 3.1: Design Results Format
Create structured results with severity categorization:

```python
class SecurityAnalysisResults:
    """Structured format for manual analysis results."""
    
    def __init__(self):
        self.summary = {}
        self.issues_by_severity = {"critical": [], "high": [], "medium": [], "low": []}
        self.remediation_suggestions = []
        self.file_coverage = {}
```

#### Step 3.2: Implement Issue Categorization
Add severity-based organization with actionable recommendations:

```python
def _categorize_issues_by_severity(self, issues: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """Categorize security issues by severity level."""
    # Severity-based categorization
    pass

def _generate_remediation_suggestions(self, issues: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Generate actionable remediation suggestions with code examples."""
    # Remediation generation
    pass
```

#### Step 3.3: Add Results Filtering and Navigation
Implement filtering capabilities for large result sets:

```python
def filter_results_by_type(self, results: Dict[str, Any], issue_types: List[str]) -> Dict[str, Any]:
    """Filter results by issue type for focused analysis."""
    # Result filtering implementation
    pass
```

### Phase 4: CI/CD Consistency Implementation (Estimated: 75 minutes)
#### Step 4.1: Align Rule Selection with CI/CD
Implement rule selection matching CI/CD validation hooks:

```python
def _get_cicd_equivalent_rules(self, context: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Get rules that match CI/CD pipeline validation hooks."""
    # CI/CD rule alignment
    pass
```

#### Step 4.2: Implement Severity Scoring Consistency
Add consistent severity calculation with CI/CD pipeline:

```python
def _calculate_cicd_consistent_score(self, issues: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Calculate severity scores consistent with CI/CD pipeline."""
    # Consistent scoring algorithm
    pass
```

#### Step 4.3: Create CI/CD Report Format Matching
Implement report format compatible with CI/CD output:

```python
def _format_as_cicd_report(self, results: Dict[str, Any]) -> Dict[str, Any]:
    """Format results to match CI/CD report structure."""
    # SARIF-compatible formatting
    pass
```

### Phase 5: Security Implementation (Estimated: 45 minutes)
#### Step 5.1: Implement Path Validation
Add comprehensive path traversal protection:

```python
def _validate_workspace_path(self, path: str) -> Path:
    """Validate workspace path against traversal attacks."""
    # Path validation with allow-lists
    pass
```

#### Step 5.2: Add Resource Limits
Implement timeout and memory controls for large analyses:

```python
def _apply_resource_limits(self, analysis_func, timeout_seconds: int = 30):
    """Apply resource limits to analysis operations."""
    # Resource limiting implementation
    pass
```

#### Step 5.3: Sanitize Display Content
Add output sanitization for IDE display:

```python
def _sanitize_for_ide_display(self, content: str) -> str:
    """Sanitize content for safe IDE display."""
    # Output sanitization
    pass
```

## Success Criteria

✅ **AC1: Command Exposure**: Manual command interface is available in Claude Code  
✅ **AC2: Comprehensive Analysis**: Command performs security analysis against all relevant Rule Cards  
✅ **AC3: Clear Results Display**: Results displayed in hierarchical, easy-to-read format  
✅ **AC4: CI/CD Consistency**: Manual results predict CI/CD pipeline outcomes  
✅ **Security Requirements**: All 5 security requirements implemented with validation  
✅ **Testing Coverage**: Unit, integration, security, and manual verification tests pass  

## Verification Steps

### Functional Testing
1. **Command Registration Verification**:
   - [ ] Execute `*security-scan-file` command in Claude Code
   - [ ] Verify command parameters are properly validated
   - [ ] Test help documentation display

2. **Single File Analysis Verification**:
   - [ ] Run analysis on Python file with known vulnerabilities
   - [ ] Verify all applicable rules are triggered
   - [ ] Confirm results display with severity categorization

3. **Workspace Analysis Verification**:
   - [ ] Execute workspace scan on multi-file project
   - [ ] Verify file discovery respects security boundaries
   - [ ] Confirm aggregated results are properly formatted

### Integration Testing
1. **Claude Code Integration**:
   - [ ] Test command execution through Claude Code interface
   - [ ] Verify results display in IDE format
   - [ ] Test error handling and user feedback

2. **Runtime Integration**:
   - [ ] Verify integration with existing SecurityRuntimeManager
   - [ ] Test package loading and rule selection
   - [ ] Confirm caching system reuse

### Security Testing
1. **Path Traversal Prevention**:
   - [ ] Test with malicious relative paths (../../../etc/passwd)
   - [ ] Test with absolute paths outside project
   - [ ] Verify workspace traversal stays within bounds

2. **Input Validation**:
   - [ ] Test with malformed file paths
   - [ ] Test with non-existent files
   - [ ] Verify parameter sanitization

3. **Resource Protection**:
   - [ ] Test with large workspace (>1000 files)
   - [ ] Verify timeout controls activate
   - [ ] Test memory usage limits

### Performance Validation
1. **Response Time Testing**:
   - [ ] Single file analysis completes under 10 seconds
   - [ ] Small workspace (<50 files) completes under 30 seconds
   - [ ] Large workspace analysis provides progress feedback

2. **Caching Effectiveness**:
   - [ ] Repeated analysis shows performance improvement
   - [ ] Package loading benefits from existing cache
   - [ ] Rule selection uses cached results

### CI/CD Consistency Verification
1. **Rule Selection Alignment**:
   - [ ] Compare manual analysis rules with CI/CD validation hooks
   - [ ] Verify same rules trigger in both contexts
   - [ ] Test edge cases for rule selection

2. **Results Format Consistency**:
   - [ ] Manual results predict CI/CD pass/fail
   - [ ] Severity scores match CI/CD calculations
   - [ ] Report format enables easy comparison

## Time Estimation

- **Total Estimated Time**: 315 minutes (5.25 hours)
- **Critical Path**: Phase 2 (Analysis Engine Extension) → Phase 4 (CI/CD Consistency)
- **Dependencies**: Successful completion of Stories 2.1 and 2.2
- **Buffer Time**: +25% (79 minutes) for unexpected integration challenges
- **Total with Buffer**: ~395 minutes (6.5 hours)

### Phase Breakdown:
1. **Phase 1**: Command Interface - 45 min
2. **Phase 2**: Analysis Engine - 90 min
3. **Phase 3**: Results Display - 60 min  
4. **Phase 4**: CI/CD Consistency - 75 min
5. **Phase 5**: Security Implementation - 45 min

## Risk Mitigation

### Technical Risks
**Risk**: Claude Code command integration complexity  
**Mitigation**: Start with simple command structure, expand iteratively  
**Fallback**: Implement as standalone script with clear instructions  

**Risk**: Workspace analysis performance issues  
**Mitigation**: Implement file filtering and progress feedback  
**Fallback**: Add configurable limits and batching  

**Risk**: CI/CD consistency validation complexity  
**Mitigation**: Focus on rule selection alignment first, format matching second  
**Fallback**: Document differences and provide mapping guide  

### Dependency Risks
**Risk**: Changes to existing Story 2.2 components  
**Mitigation**: Use extension patterns rather than modification  
**Fallback**: Create independent analysis module with shared interfaces  

**Risk**: Claude Code platform limitations  
**Mitigation**: Research command capabilities early in Phase 1  
**Fallback**: Implement as enhanced sub-agent with manual trigger  

### Resource Constraints  
**Risk**: Large workspace analysis resource consumption  
**Mitigation**: Implement progressive analysis with user feedback  
**Fallback**: Add workspace size limits and analysis batching  

### Timeline Risks
**Risk**: Integration testing complexity  
**Mitigation**: Create comprehensive test suite early  
**Fallback**: Focus on core functionality, defer advanced features  

### Rollback Plans
If critical issues arise:
1. **Phase 1-2 Issues**: Revert to enhanced Story 2.2 sub-agent
2. **Phase 3-4 Issues**: Implement basic results format, defer CI/CD consistency
3. **Phase 5 Issues**: Add basic security controls, document remaining requirements

## Next Steps

### Immediate Follow-Up (After Story 2.3 Completion)
- **Story 2.4**: Enhanced reporting and analytics features
- **Story 3.1**: CI/CD pipeline integration (Epic 3)
- **Performance Optimization**: Based on real-world usage patterns

### Integration Points
- **CI/CD Pipeline**: Direct integration with GitHub Actions workflow
- **IDE Plugins**: Extension to other IDE platforms beyond Claude Code
- **Report Export**: Integration with security reporting tools

### Monitoring and Maintenance
- **Usage Analytics**: Track command usage patterns and performance metrics
- **Rule Coverage**: Monitor which rules are most frequently triggered
- **Performance Monitoring**: Track analysis time trends and optimization opportunities

### Documentation Updates
- **User Guide**: Command usage examples and best practices
- **Developer Documentation**: Extension points for future enhancements  
- **Security Guide**: Security considerations and threat model updates