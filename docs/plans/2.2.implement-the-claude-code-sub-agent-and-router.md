# Story 2.2 Implementation Plan: Implement the Claude Code Sub-Agent and Router

## Overview

This implementation plan creates a Claude Code sub-agent that provides real-time security guidance by integrating with the AgenticRuntime core from Story 2.1. The sub-agent will load compiled security packages and deliver context-aware, actionable security recommendations to developers within their IDE workflow, with performance targets under 2 seconds.

## Pre-Implementation Checklist

### Prerequisites Verification
- [ ] Verify Story 2.1 AgenticRuntime core is complete and tested
- [ ] Confirm 5 compiled agent packages exist in expected location (`dist/agents/`)
- [ ] Validate existing runtime components pass all security tests
- [ ] Ensure Python 3.11+ environment with required dependencies

### Tool/Environment Requirements
- [ ] Claude Code development environment access
- [ ] Claude Code sub-agent SDK or API documentation
- [ ] Performance profiling tools for sub-2-second requirement validation
- [ ] pytest framework for comprehensive testing

### Architecture/Design Dependencies
- [ ] Story 2.1 components: AgenticRuntime, PackageLoader, RuleSelector, LLMInterface
- [ ] Story 1.3 compiled packages: agent.*.json files with Rule Cards
- [ ] Existing security validation patterns from tests/security/

### Security Considerations
- [ ] Review input sanitization requirements for user code processing
- [ ] Validate package loading security from trusted sources only
- [ ] Ensure no sensitive data logging or external transmission
- [ ] Plan for attribution compliance in generated guidance

## Implementation Steps

### Phase 1: Claude Code Sub-Agent Implementation (Estimated: 1 hour)

#### Step 1.1: Create Sub-Agent Configuration File
Create `.claude/agents/security-guidance.md` with specific configuration:
```markdown
---
name: security-guidance
description: Security review specialist. Analyzes code for vulnerabilities using compiled Rule Cards and provides real-time actionable guidance with secure code snippets.
tools: Read, Grep, Bash
---

You are a security guidance specialist that provides real-time vulnerability analysis and secure coding recommendations. When activated, you:

1. Load compiled security packages from app/dist/agents/ 
2. Analyze user's code context using AgenticRuntime from app/runtime/
3. Generate contextual security guidance under 2 seconds
4. Provide actionable secure code snippets from Rule Cards
5. Maintain attribution compliance and prevent sensitive data exposure

Focus on practical, implementable security recommendations that don't disrupt developer workflow.
```

#### Step 1.2: Validate Sub-Agent File Structure
- Ensure `.claude/agents/` directory exists in project
- Verify sub-agent name follows lowercase convention
- Test sub-agent activation and tool restrictions
- **Expected Outcome**: Functioning Claude Code sub-agent foundation

### Phase 2: Runtime Integration Implementation (Estimated: 3 hours)

#### Step 2.1: Create Runtime Initialization Logic
Sub-agent system prompt will call Python scripts to initialize runtime:
```python
# app/claude_code/initialize_security_runtime.py
#!/usr/bin/env python3
import sys
sys.path.append('app/runtime')
from core import AgenticRuntime

def initialize_security_guidance():
    """Initialize security runtime for Claude Code sub-agent."""
    runtime = AgenticRuntime()
    # Load available compiled packages
    runtime.load_packages('app/dist/agents/')
    return runtime
```

#### Step 2.2: Create Context Analysis Helper
```python
# app/claude_code/analyze_context.py
def analyze_code_context(file_path, code_content):
    """Analyze code context and select relevant security rules."""
    runtime = initialize_security_guidance()
    context = runtime.create_context(file_path, code_content)
    selected_rules = runtime.select_rules(context)
    return selected_rules
```

#### Step 2.3: Implement Guidance Generation Script
- Create Python script that sub-agent can call via Bash tool
- Integrate with Story 2.1 LLMInterface for guidance generation
- Add performance caching and optimization
- **Expected Outcome**: Sub-agent can generate guidance via script execution

### Phase 3: Real-Time Guidance Generation (Estimated: 3 hours)

#### Step 3.1: Implement Guidance Generation Engine
```python
def generate_security_guidance(self, code_context):
    # Use AgenticRuntime rule selection
    # Format guidance for Claude Code display
    # Ensure sub-2-second response time
    pass
```

#### Step 3.2: Create Structured Guidance Formatting
- Design guidance output format for Claude Code
- Implement non-intrusive display mechanism
- Add actionable recommendation structure
- **Expected Outcome**: User-friendly guidance presentation

#### Step 3.3: Add Input Sanitization
- Implement code context sanitization before LLM processing
- Add injection attack prevention
- Validate user input safety
- **Expected Outcome**: Secure user code processing

### Phase 4: Secure Code Snippet Generation (Estimated: 2 hours)

#### Step 4.1: Implement Snippet Generation
- Extract secure code examples from Rule Cards
- Add context-aware snippet recommendations
- Implement code style consistency checks
- **Expected Outcome**: Actionable secure code suggestions

#### Step 4.2: Snippet Security Validation
- Validate generated snippets for embedded vulnerabilities
- Add security scanning of generated code
- Implement snippet approval workflow
- **Expected Outcome**: Verified secure code snippets

### Phase 5: Performance Optimization (Estimated: 3 hours)

#### Step 5.1: Implement Caching Mechanisms
```python
class PerformanceCache:
    def __init__(self):
        self.package_cache = {}
        self.rule_cache = {}
    
    def get_cached_rules(self, context_hash):
        # Return cached rule selection results
        pass
```

#### Step 5.2: Optimize LLM Prompt Construction
- Streamline prompt templates for faster processing
- Implement prompt caching for common patterns
- Add timeout handling for slow responses
- **Expected Outcome**: Consistent sub-2-second response times

#### Step 5.3: Add Performance Monitoring
- Implement response time tracking
- Add performance metrics collection
- Create performance validation tests
- **Expected Outcome**: Measurable performance compliance

## Success Criteria

### Functional Requirements ✅
- [ ] Sub-agent activates automatically based on Claude Code file context
- [ ] Loads compiled JSON packages successfully on initialization  
- [ ] Generates contextual security guidance using Rule Cards and user code
- [ ] Displays guidance in non-intrusive, real-time manner
- [ ] Provides actionable secure code snippets from Rule Cards
- [ ] Maintains response times under 2 seconds consistently

### Security Requirements ✅
- [ ] No direct authentication required - leverages Claude Code auth
- [ ] Only accesses packages from trusted project boundaries
- [ ] Sanitizes all user code input to prevent injection attacks
- [ ] Protects user code context and guidance from unauthorized logging
- [ ] Maintains Rule Card attribution notices in generated content

### Integration Requirements ✅
- [ ] Integrates seamlessly with Claude Code routing system
- [ ] Successfully connects to Story 2.1 AgenticRuntime components
- [ ] Utilizes compiled packages from Story 1.3 without modification
- [ ] Maintains compatibility with existing LLMInterface patterns

## Verification Steps

### Functional Testing
1. **Sub-Agent Activation Testing**
   ```bash
   # Test activation with different file types
   python -m pytest tests/claude_code/test_activation.py -v
   ```

2. **Guidance Generation Testing**
   ```bash
   # Test guidance quality and accuracy
   python -m pytest tests/claude_code/test_guidance.py -v
   ```

3. **Performance Validation**
   ```bash
   # Test response time requirements
   python -m pytest tests/claude_code/test_performance.py -v
   ```

### Security Validation
1. **Input Sanitization Testing**
   - Test malicious code context injection prevention
   - Validate secure package loading mechanisms
   - Verify no sensitive data leakage

2. **Attribution Compliance Testing**
   - Verify Rule Card attribution in generated guidance
   - Test compliance with organizational policy protection

### Integration Testing
1. **Runtime Integration Testing**
   ```bash
   # Test integration with Story 2.1 components
   python -m pytest tests/claude_code/test_integration.py -v
   ```

2. **End-to-End Workflow Testing**
   - Manual testing in Claude Code environment
   - Verify complete guidance workflow
   - Test multiple file types and contexts

## Time Estimation

### Total Estimated Time: **12 hours**

| Phase | Estimated Time | Critical Path |
|-------|---------------|---------------|
| Phase 1: Sub-Agent Setup | 1 hour | ✅ Yes - foundation |
| Phase 2: Runtime Integration | 3 hours | ✅ Yes - core functionality |
| Phase 3: Guidance Generation | 3 hours | ✅ Yes - main feature |
| Phase 4: Snippet Generation | 2 hours | No - can be done in parallel |
| Phase 5: Performance Optimization | 3 hours | No - optimization phase |

### Dependencies
- **Story 2.1**: Must be complete and tested (✅ Done)
- **Story 1.3**: Compiled packages must be available (✅ Done)
- **Claude Code Access**: Need development environment access

### Buffer Time
- **Research Buffer**: +2 hours for Claude Code integration complexity
- **Testing Buffer**: +2 hours for comprehensive security validation
- **Total with Buffer**: **18 hours**

## Risk Mitigation

### Technical Risks

**Risk 1: Claude Code Sub-Agent Performance**
- **Mitigation**: Sub-agents start with clean context, may add latency - optimize initialization
- **Implementation**: Use caching and pre-loaded runtime components
- **Measurement**: Continuous performance monitoring during development

**Risk 2: Performance Requirements (Sub-2-Second)**
- **Mitigation**: Performance optimization as dedicated phase with caching
- **Measurement**: Continuous performance monitoring during development
- **Fallback**: Graceful degradation with timeout handling

**Risk 3: Security Control Integration**
- **Mitigation**: Reuse proven patterns from Story 2.1 security implementation
- **Validation**: Comprehensive security testing at each phase
- **Compliance**: Regular security validation throughout development

### Dependency Risks

**Risk 4: Runtime Component Changes**
- **Mitigation**: Lock Story 2.1 components as stable interface
- **Detection**: Integration tests will catch interface changes
- **Response**: Coordinate with previous story maintainer if changes needed

### Resource Constraints

**Risk 5: Claude Code Environment Access**
- **Mitigation**: Ensure development environment access before starting
- **Alternative**: Develop against Claude Code documentation with later integration testing
- **Escalation**: Request access support if blocked

## Next Steps

### After Story 2.2 Completion
1. **Story 2.3**: Manual On-Demand Execution - extends sub-agent with manual trigger capability
2. **Epic 3**: CI/CD Advisory Integration - creates consistency validation pipeline
3. **Performance Monitoring**: Establish ongoing performance metrics for deployed sub-agent
4. **User Feedback Integration**: Collect developer feedback on guidance quality and workflow integration

### Integration Points
- **Claude Code Ecosystem**: Sub-agent becomes part of Claude Code security toolkit
- **CI/CD Pipeline**: Foundation for Story 3.x consistency validation
- **Rule Card Updates**: Sub-agent automatically picks up new compiled packages

### Documentation Updates
- Update main README with Claude Code sub-agent usage instructions
- Create developer onboarding guide for sub-agent activation
- Document performance tuning and troubleshooting procedures