# Epic 2.6 Implementation Plan: Semtools OWASP CheatSheets and ASVS Corpus Integration

## Overview

This plan implements a local semantic search corpus of OWASP CheatSheets and ASVS standards using semtools, enabling developers to quickly find relevant security guidance within their development environment. The implementation includes corpus normalization, search infrastructure, provenance tracking, and security controls to ensure safe operation.

## Pre-Implementation Checklist

### Prerequisites Verification
- [ ] **Rust Toolchain**: Verify Rust is available or install using rustup
- [ ] **Python Environment**: Confirm Python 3.11+ is available for scripting
- [ ] **Git Access**: Ensure ability to add submodules and commit changes
- [ ] **File System Permissions**: Verify write access to vendor/, research/, tools/, docs/ directories
- [ ] **Attribution Requirements**: Confirm understanding of CC BY-SA 4.0 license requirements

### Tool/Environment Requirements
- [ ] **Rustup Installation**: `sudo snap install rustup --classic` (if not available)
- [ ] **Rust Stable Toolchain**: `rustup install stable && rustup default stable`
- [ ] **Semtools Installation**: `cargo install semtools --no-default-feature --features=search`
- [ ] **Directory Structure**: Create required directories (research/search_corpus, vendor)
- [ ] **Make Utility**: Ensure make is available for build targets

### Access Requirements
- [ ] **GitHub Submodule Access**: Ability to add https://github.com/OWASP/CheatSheetSeries
- [ ] **File System Write**: Permission to create corpus files and wrapper scripts
- [ ] **Documentation Access**: Ability to update docs/ATTRIBUTION.md

### Architecture/Design Dependencies
- [ ] **Unified Project Structure**: Follow docs/architecture/unified-project-structure.md patterns
- [ ] **Tech Stack Alignment**: Implement using Python 3.11+ for scripts per tech-stack.md
- [ ] **Security Standards**: Apply python-secure-coding.md practices

### Security Considerations
- [ ] **Input Validation Framework**: Plan for query sanitization and path validation
- [ ] **Resource Limits**: Design bounded search operations to prevent DoS
- [ ] **Access Control**: Implement directory allowlisting for search operations
- [ ] **Audit Logging**: Plan comprehensive logging for search operations
- [ ] **Content Integrity**: Design SHA256 checksum validation system

## Implementation Steps

### Phase 1: Environment Setup and Semtools Installation (Estimated: 30 minutes)

#### Step 1.1: Install Rust Toolchain
```bash
# Check if Rust is already available
rustc --version || {
    sudo snap install rustup --classic
    rustup install stable
    rustup default stable
    rustc --version
}
```
**Expected Outcome**: Rust compiler available with stable toolchain

#### Step 1.2: Install Semtools with Search Features
```bash
cargo install semtools --no-default-features --features=search
# Verify installation
which search
search --help
```
**Expected Outcome**: Semtools search binary available and functional

#### Step 1.3: Create Directory Structure
```bash
mkdir -p research/search_corpus/owasp
mkdir -p vendor
mkdir -p tools
```
**Expected Outcome**: Required directories created with proper permissions

### Phase 2: OWASP CheatSheets Integration (Estimated: 45 minutes)

#### Step 2.1: Add OWASP CheatSheets as Git Submodule
```bash
git submodule add https://github.com/OWASP/CheatSheetSeries vendor/owasp-cheatsheets
cd vendor/owasp-cheatsheets
git checkout master  # or main branch
cd ../..
```
**Expected Outcome**: OWASP CheatSheets available in vendor/owasp-cheatsheets/

#### Step 2.2: Update Attribution Documentation
```python
# Add to docs/ATTRIBUTION.md
attribution_text = """
## OWASP CheatSheet Series
- **Source**: https://github.com/OWASP/CheatSheetSeries
- **License**: CC BY-SA 4.0
- **Usage**: Semantic search corpus for security guidance
- **Attribution**: © OWASP Foundation, licensed under CC BY-SA 4.0
"""
```
**Expected Outcome**: Proper attribution documented per CC BY-SA 4.0 requirements

#### Step 2.3: Create OWASP Normalization Script
Create `tools/render_owasp_for_search.py` with the following functionality:
```python
#!/usr/bin/env python3
"""
OWASP CheatSheet Normalization for Semantic Search
Processes OWASP cheatsheets into searchable corpus format
"""
import os
import re
import hashlib
import yaml
from pathlib import Path

def normalize_owasp_file(source_path, output_dir):
    """Normalize OWASP cheatsheet to searchable format"""
    # Read source markdown
    # Extract title, headings, guidance, code samples
    # Remove navigation/footer noise
    # Generate SHA256 checksum
    # Add front-matter with tags and metadata
    # Write to research/search_corpus/owasp/
```
**Expected Outcome**: Script ready to process OWASP files with security controls

### Phase 3: Corpus Normalization Implementation (Estimated: 60 minutes)

#### Step 3.1: Implement Content Processing Logic
```python
def extract_security_tags(content, filename):
    """Extract relevant security tags from content and filename"""
    tag_patterns = {
        'authentication': r'(auth|login|credential|password)',
        'jwt': r'(jwt|json web token)',
        'docker': r'(docker|container|dockerfile)',
        'secrets': r'(secret|api key|token|credential)',
        'session_management': r'(session|cookie|csrf)',
        'cryptography': r'(crypto|encrypt|hash|cipher)',
        'input_validation': r'(validation|sanitiz|xss|injection)'
    }
    # Implementation logic here
```

#### Step 3.2: Implement Front-Matter Generation
```python
def generate_front_matter(source_path, content, tags):
    """Generate YAML front-matter with metadata"""
    sha256_hash = hashlib.sha256(content.encode()).hexdigest()
    front_matter = {
        'source': 'owasp-cheatsheet-series',
        'path': str(source_path),
        'tags': tags,
        'license': 'CC-BY-SA-4.0',
        'sha256': sha256_hash
    }
    return yaml.dump(front_matter, default_flow_style=False)
```

#### Step 3.3: Implement File Processing Pipeline
```python
def process_all_cheatsheets():
    """Process all OWASP cheatsheets into corpus format"""
    source_dir = Path('vendor/owasp-cheatsheets/cheatsheets')
    output_dir = Path('research/search_corpus/owasp')
    
    for md_file in source_dir.glob('*.md'):
        # Process file with security validation
        # Apply input sanitization
        # Generate normalized output
        pass
```

### Phase 4: ASVS Integration (Estimated: 40 minutes)

#### Step 4.1: Extend Script for ASVS Processing
```python
def process_asvs_content(asvs_source_dir):
    """Process ASVS standards similar to OWASP"""
    # Map ASVS verification requirements to rule card tags
    # Ensure consistent tagging across OWASP and ASVS
    # Generate normalized ASVS files
```

#### Step 4.2: Implement Consistent Tagging System
```python
SECURITY_DOMAIN_TAGS = {
    'V1': ['authentication', 'architecture'],
    'V2': ['authentication', 'session_management'],
    'V3': ['session_management', 'cookies'],
    'V4': ['access_control', 'authorization'],
    'V5': ['input_validation', 'output_encoding'],
    # Continue mapping...
}
```

### Phase 5: Search Interface and Wrapper Scripts (Estimated: 45 minutes)

#### Step 5.1: Create Semtools Wrapper Script
Create `tools/semsearch.sh`:
```bash
#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
CORPUS="$ROOT/research/search_corpus"

# Input validation
if [[ ! "${1:-}" =~ ^[a-zA-Z0-9[:space:]._-]+$ ]]; then
    echo "Error: Invalid query format" >&2
    exit 1
fi

# Build corpus if missing
if [ ! -d "$CORPUS/owasp" ]; then
    echo "[semsearch] Building OWASP corpus..."
    python3 "$ROOT/tools/render_owasp_for_search.py"
fi

# Execute search with resource limits
timeout 10s search "${1:-""}" "$CORPUS"/owasp/*.md \
    --top-k 5 \
    --max-distance 0.32 \
    --n-lines 5 \
    || echo "Search timeout or error occurred"
```

#### Step 5.2: Add Makefile Targets
```makefile
.PHONY: semsearch-build semsearch

semsearch-build:
	$(PY) tools/render_owasp_for_search.py

semsearch:
	tools/semsearch.sh "$(q)"
```

### Phase 6: Provenance Tracking and Security Controls (Estimated: 50 minutes)

#### Step 6.1: Implement Provenance Metadata
```python
def add_provenance_tracking(search_results):
    """Add provenance data to search results"""
    provenance_data = {
        "path": result_file_path,
        "sha256": file_checksum,
        "lines": f"{start_line}-{end_line}",
        "source": "owasp-cheatsheet-series"
    }
    return search_results_with_provenance
```

#### Step 6.2: Implement Security Controls
```python
def validate_search_query(query):
    """Validate and sanitize search queries"""
    # Prevent directory traversal
    if '..' in query or '/' in query:
        raise ValueError("Invalid query: directory traversal detected")
    
    # Limit query length
    if len(query) > 200:
        raise ValueError("Query too long")
    
    # Sanitize special characters
    sanitized = re.sub(r'[^\w\s\-_.]', '', query)
    return sanitized

def enforce_access_control(file_path):
    """Ensure search only accesses allowlisted directories"""
    allowed_paths = [
        'research/search_corpus/owasp/',
        'docs/'
    ]
    # Validation logic here
```

### Phase 7: Automated Sync and Maintenance (Estimated: 30 minutes)

#### Step 7.1: Create Sync Workflow Script
```bash
#!/bin/bash
# tools/sync_corpus.sh
set -euo pipefail

echo "Updating OWASP submodule..."
git submodule update --remote vendor/owasp-cheatsheets

echo "Rebuilding corpus..."
python3 tools/render_owasp_for_search.py

echo "Validating checksums..."
python3 tools/validate_corpus_integrity.py

echo "Sync complete"
```

#### Step 7.2: Implement Integrity Validation
```python
def validate_corpus_integrity():
    """Validate corpus files against stored checksums"""
    for corpus_file in Path('research/search_corpus/owasp').glob('*.md'):
        # Extract stored SHA256 from front-matter
        # Recalculate current SHA256
        # Compare and report differences
        pass
```

### Phase 8: Optional Runtime Integration (Estimated: 40 minutes)

#### Step 8.1: Implement Feature Flag System
```python
class FeatureFlags:
    def __init__(self):
        self.runtime_search_enabled = os.getenv('ENABLE_RUNTIME_SEARCH', 'false').lower() == 'true'
    
    def is_runtime_search_enabled(self):
        return self.runtime_search_enabled
```

#### Step 8.2: Implement Bounded Augmentation
```python
def runtime_semantic_search(query, max_results=5, max_tokens=150):
    """Runtime search with strict resource limits"""
    if not FeatureFlags().is_runtime_search_enabled():
        return None
    
    try:
        # Execute search with timeout
        results = execute_bounded_search(query, max_results)
        # Truncate to token limit
        return truncate_results(results, max_tokens)
    except Exception as e:
        # Log error and return None for graceful fallback
        logger.error(f"Runtime search failed: {e}")
        return None
```

## Success Criteria

### Acceptance Criteria Mapping
✅ **AC1**: OWASP CheatSheets vendored as git submodule with CC BY-SA 4.0 attribution  
✅ **AC2**: Normalization script converts OWASP CheatSheets to `research/search_corpus/owasp/`  
✅ **AC3**: ASVS standards processed and integrated with consistent tagging  
✅ **AC4**: Semtools installed with wrapper scripts and Makefile targets  
✅ **AC5**: Search results include provenance (file paths, checksums, line numbers)  
✅ **AC6**: Automated sync process maintains corpus freshness  
✅ **AC7**: Runtime integration feature-flagged with ≤5 results, ≤150 tokens limits  
✅ **AC8**: Search performance <1s with graceful offline fallback  

### Security Requirements Validation
✅ **SR1**: Attribution compliance in docs/ATTRIBUTION.md  
✅ **SR2**: SHA256 checksums for content integrity  
✅ **SR3**: Access control limited to allowlisted directories  
✅ **SR4**: Input validation prevents injection attacks  
✅ **SR5**: Resource limits prevent DoS (top-k ≤ 5, tokens ≤ 150)  

## Verification Steps

### Functional Testing
1. **Installation Verification**:
   ```bash
   rustc --version
   cargo --version
   which search
   search --help
   ```

2. **Corpus Building**:
   ```bash
   python3 tools/render_owasp_for_search.py
   ls -la research/search_corpus/owasp/
   head research/search_corpus/owasp/*.md
   ```

3. **Search Functionality**:
   ```bash
   make semsearch q="jwt token validation"
   make semsearch q="docker container security"
   tools/semsearch.sh "session fixation prevention"
   ```

### Integration Testing
1. **End-to-End Pipeline**: Submodule → normalization → search → results
2. **Makefile Targets**: Verify `make semsearch-build` and `make semsearch` work
3. **Sync Workflow**: Test corpus updates with `tools/sync_corpus.sh`
4. **Feature Flag**: Test runtime integration enable/disable

### Security Validation
1. **Input Validation**: Test queries with directory traversal attempts
2. **Resource Limits**: Verify search operations respect time/result limits  
3. **Access Control**: Confirm search restricted to allowlisted directories
4. **Content Integrity**: Validate SHA256 checksums detect tampering
5. **Attribution Compliance**: Verify CC BY-SA 4.0 attribution is complete
6. **Audit Logging**: Confirm search operations are logged appropriately

### Performance Checks
1. **Search Speed**: Verify <1s response time with representative queries
2. **Resource Usage**: Monitor memory/CPU usage during search operations
3. **Corpus Size**: Verify normalized corpus is manageable size
4. **Fallback Behavior**: Test graceful degradation when search fails

### Manual Verification
1. **Search Quality**: Manually review search results for relevance
2. **Corpus Content**: Spot-check normalized files for content quality
3. **Attribution Review**: Verify attribution documentation is accurate
4. **Documentation**: Confirm all scripts and tools are properly documented

## Time Estimation

### Detailed Breakdown
- **Phase 1** (Environment Setup): 30 minutes
- **Phase 2** (OWASP Integration): 45 minutes  
- **Phase 3** (Corpus Normalization): 60 minutes
- **Phase 4** (ASVS Integration): 40 minutes
- **Phase 5** (Search Interface): 45 minutes
- **Phase 6** (Security Controls): 50 minutes
- **Phase 7** (Sync/Maintenance): 30 minutes
- **Phase 8** (Runtime Integration): 40 minutes

**Total Estimated Time**: 5 hours 40 minutes (340 minutes)

### Critical Path
1. Environment Setup → OWASP Integration → Corpus Normalization → Search Interface
2. Security controls implementation runs parallel to functional development
3. Runtime integration is optional and can be deferred

### Dependencies
- **External**: GitHub access for OWASP submodule
- **Internal**: None (Story 2.6 is self-contained)
- **Tools**: Rust ecosystem availability

### Buffer Time
- **Technical Issues**: +60 minutes for dependency/environment issues
- **Testing/Debugging**: +45 minutes for validation and fixes
- **Documentation**: +15 minutes for final documentation updates

**Total with Buffer**: 7 hours (420 minutes)

## Risk Mitigation

### Technical Risks and Solutions

**Risk**: Rust/Cargo installation issues on target systems
- **Mitigation**: Provide alternative installation methods, include dependency check scripts
- **Fallback**: Document manual compilation process for semtools

**Risk**: OWASP CheatSheets repository structure changes breaking normalization
- **Mitigation**: Version pinning of git submodule, robust parsing with fallbacks
- **Monitoring**: Automated checks for structure changes during sync

**Risk**: Large corpus size impacting search performance
- **Mitigation**: Content filtering during normalization, pagination of results
- **Optimization**: Implement corpus splitting by domain if needed

**Risk**: Security control bypasses in search queries
- **Mitigation**: Multiple validation layers, comprehensive input sanitization
- **Testing**: Dedicated penetration testing of search interface

### Dependency Risks
- **Git Submodule**: OWASP repository availability or access issues
  - *Solution*: Local mirror backup, graceful degradation documentation
- **Rust Ecosystem**: Cargo/crates.io availability
  - *Solution*: Offline installation guides, binary distribution options

### Resource Constraints
- **Disk Space**: Large corpus files consuming storage
  - *Solution*: Compression, selective content inclusion, cleanup processes
- **Memory Usage**: Search operations consuming excessive RAM
  - *Solution*: Streaming processing, result pagination, memory limits

### Timeline Risks
- **Complex Security Requirements**: Additional time for compliance validation
  - *Buffer*: 25% time buffer included in estimates
- **Integration Issues**: Unexpected compatibility problems
  - *Mitigation*: Early integration testing, modular implementation

### Rollback Plans
1. **Git Submodule Issues**: Remove submodule, revert to manual documentation references
2. **Performance Problems**: Disable runtime integration, keep manual search only  
3. **Security Concerns**: Implement restrictive mode with minimal search capabilities
4. **Complete Failure**: Document manual process for accessing OWASP/ASVS content

## Next Steps

### Immediate Follow-ups
1. **Story 2.7** (if exists): Integration with existing sub-agent routing system
2. **Performance Optimization**: Based on initial usage metrics and feedback
3. **Corpus Expansion**: Addition of other security standards (NIST, CIS, etc.)

### Integration Points
- **Sub-Agent System**: Connect semantic search to existing agent routing in Epic 2
- **CI/CD Pipeline**: Integrate corpus validation into existing security workflows
- **Documentation System**: Link semantic search results to rule card compilation

### Monitoring and Maintenance
- **Corpus Freshness**: Weekly automated sync with upstream OWASP repository
- **Performance Metrics**: Search response time, result relevance scoring
- **Security Monitoring**: Audit log analysis, access pattern reviews
- **Usage Analytics**: Track query patterns to optimize corpus organization

### Documentation Updates
- **Developer Guide**: Add semantic search usage instructions
- **Security Playbook**: Document security controls and validation procedures  
- **Troubleshooting Guide**: Common issues and resolution steps
- **Architecture Decision Records**: Document tool choices and trade-offs

This implementation plan provides a comprehensive roadmap for implementing Story 2.6 with strong security controls, performance considerations, and maintainable architecture aligned with the existing system design.