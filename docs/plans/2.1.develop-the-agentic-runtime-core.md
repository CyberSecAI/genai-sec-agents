# Epic 2.1 Implementation Plan: Develop the Agentic Runtime Core

## Overview
This plan outlines the implementation of Story 2.1 - developing the core runtime system that can load and interpret compiled security agent packages to provide foundational support for in-IDE security guidance.

## Prerequisites
- [x] Story 1.3 completed with 5 compiled agent packages available
- [x] Python 3.11+ development environment configured
- [x] Project structure established in `app/` directory
- [x] Compiled agent packages validated and accessible at `app/dist/agents/`
- [ ] pytest installed for testing infrastructure
- [ ] Development security guidelines loaded from expansion packs

## Implementation Phases

### Phase 1: Core Infrastructure Setup (2-3 hours)
**Objective**: Establish the fundamental runtime architecture with secure JSON processing

#### Step 1.1: Create Runtime Module Structure
```bash
mkdir -p app/runtime
touch app/runtime/__init__.py
touch app/runtime/core.py
touch app/runtime/package_loader.py
touch app/runtime/rule_selector.py  
touch app/runtime/llm_interface.py
```

#### Step 1.2: Implement AgenticRuntime Core Class
Create `app/runtime/core.py` with:
```python
class AgenticRuntime:
    def __init__(self, package_directory="app/dist/agents"):
        self.package_directory = package_directory
        self.loaded_packages = {}
        self.package_loader = PackageLoader()
        self.rule_selector = RuleSelector()
        self.llm_interface = LLMInterface()
    
    def load_agent(self, agent_name: str) -> bool:
        # Secure package loading implementation
        pass
    
    def get_guidance(self, context: dict, agent_name: str = None) -> dict:
        # Main interface for IDE integration
        pass
```

#### Step 1.3: Implement Secure JSON Package Loading
Create `app/runtime/package_loader.py` with security controls:
```python
import json
import os
from typing import Dict, Optional
from pathlib import Path

class PackageLoader:
    MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB limit
    
    def load_package(self, package_path: str) -> Optional[Dict]:
        # Validate file path to prevent traversal
        # Check file size limits
        # Safe JSON parsing with error handling
        # Package structure validation
        pass
```

**Expected Outcomes**: 
- Runtime module structure created
- Core classes with security-first design
- Safe JSON loading with validation

### Phase 2: Package Loading and Rule Management (3-4 hours)
**Objective**: Implement robust loading and management of compiled agent packages

#### Step 2.1: Package Structure Validation
Implement schema validation for loaded packages:
```python
PACKAGE_SCHEMA = {
    "agent": {
        "name": str,
        "version": str,
        "build_date": str,
        "source_digest": str
    },
    "rules": [RuleCard],
    "validation_hooks": Dict[str, List[str]]
}
```

#### Step 2.2: Rule Data Structure Management
Create internal data structures for efficient rule access:
```python
class RuleManager:
    def __init__(self):
        self.rules_by_scope = {}
        self.rules_by_severity = {}
        self.rules_by_domain = {}
        self.validation_hooks = {}
    
    def index_rules(self, rules: List[Dict]):
        # Create efficient lookup indexes
        pass
```

#### Step 2.3: Metadata Extraction and Attribution
Preserve package metadata and attribution notices:
```python
def extract_metadata(self, package: Dict) -> Dict:
    return {
        "agent_name": package["agent"]["name"],
        "version": package["agent"]["version"], 
        "build_date": package["agent"]["build_date"],
        "source_digest": package["agent"]["source_digest"],
        "attribution": package["agent"]["attribution"]
    }
```

**Expected Outcomes**:
- All 5 agent packages successfully loaded
- Rule data properly indexed and accessible
- Package metadata preserved with attribution

### Phase 3: Context-Aware Rule Selection (2-3 hours) 
**Objective**: Implement intelligent rule filtering based on development context

#### Step 3.1: Context Analysis Engine
Create `app/runtime/rule_selector.py`:
```python
class RuleSelector:
    def __init__(self):
        self.scope_patterns = self._load_scope_patterns()
        self.file_type_mapping = self._load_file_mappings()
    
    def select_rules(self, context: Dict, rules: List[Dict]) -> List[Dict]:
        # File extension matching
        # Directory pattern matching
        # Scope-based filtering
        # Domain relevance scoring
        pass
```

#### Step 3.2: Multi-Context Support
Implement support for various context types:
- File extensions (`.py`, `.js`, `.java`, `.dockerfile`)
- Directory patterns (`src/`, `test/`, `config/`)
- Code patterns (API endpoints, database queries)
- Security domains (secrets, authentication, authorization)

#### Step 3.3: Performance Optimization
Ensure sub-2 second response times:
```python
def optimized_rule_selection(self, context: Dict, max_rules: int = 10) -> List[Dict]:
    # Pre-computed indexes for fast lookup
    # Relevance scoring with early termination
    # Caching for repeated contexts
    pass
```

**Expected Outcomes**:
- Context-aware rule filtering working
- Support for multiple context types
- Performance meets real-time requirements

### Phase 4: Model-Agnostic LLM Interface (3-4 hours)
**Objective**: Design flexible interface supporting multiple LLM providers

#### Step 4.1: Abstract LLM Provider Interface
Create `app/runtime/llm_interface.py`:
```python
from abc import ABC, abstractmethod

class LLMProvider(ABC):
    @abstractmethod
    def generate_guidance(self, prompt: str, rules: List[Dict]) -> str:
        pass
    
    @abstractmethod
    def format_rules_for_prompt(self, rules: List[Dict]) -> str:
        pass

class ClaudeProvider(LLMProvider):
    def generate_guidance(self, prompt: str, rules: List[Dict]) -> str:
        # Anthropic Claude integration
        pass

class GPTProvider(LLMProvider): 
    def generate_guidance(self, prompt: str, rules: List[Dict]) -> str:
        # OpenAI GPT integration
        pass
```

#### Step 4.2: Prompt Template System
Design reusable prompt templates:
```python
class PromptTemplates:
    SECURITY_GUIDANCE = """
    Based on the following security rules, provide guidance for this code:
    
    Code Context: {context}
    
    Relevant Security Rules:
    {rules}
    
    Provide specific, actionable recommendations.
    """
```

#### Step 4.3: Response Formatting
Standardize LLM response processing:
```python
def format_response(self, raw_response: str) -> Dict:
    return {
        "guidance": self.extract_guidance(raw_response),
        "suggestions": self.extract_suggestions(raw_response),
        "severity": self.extract_severity(raw_response),
        "references": self.extract_references(raw_response)
    }
```

**Expected Outcomes**:
- Model-agnostic interface implemented
- Support for Claude and GPT providers
- Consistent response formatting

### Phase 5: Testing Infrastructure (4-5 hours)
**Objective**: Comprehensive testing with all compiled packages

#### Step 5.1: Unit Testing Framework
Create `tests/runtime/` structure:
```bash
mkdir -p tests/runtime
touch tests/runtime/__init__.py
touch tests/runtime/test_core.py
touch tests/runtime/test_package_loader.py
touch tests/runtime/test_rule_selector.py
touch tests/runtime/test_llm_interface.py
```

#### Step 5.2: Package Loading Tests
Test with all 5 agent packages:
```python
def test_package_loading():
    loader = PackageLoader()
    
    # Test each compiled package
    packages = [
        "secrets-specialist.json",
        "web-security-specialist.json", 
        "genai-security-specialist.json",
        "container-security-specialist.json",
        "comprehensive-security-agent.json"
    ]
    
    for package in packages:
        result = loader.load_package(f"app/dist/agents/{package}")
        assert result is not None
        assert "agent" in result
        assert "rules" in result
```

#### Step 5.3: Security Testing
Test malicious input handling:
```python
def test_malicious_json_handling():
    loader = PackageLoader()
    
    # Test oversized files
    # Test malformed JSON
    # Test JSON bombs
    # Test path traversal attempts
    pass
```

#### Step 5.4: Integration Testing
End-to-end workflow testing:
```python
def test_complete_workflow():
    runtime = AgenticRuntime()
    runtime.load_agent("secrets-specialist")
    
    context = {
        "file_path": "src/auth.py",
        "file_content": "jwt_secret = 'hardcoded_secret'"
    }
    
    guidance = runtime.get_guidance(context, "secrets-specialist")
    assert guidance is not None
    assert "guidance" in guidance
```

**Expected Outcomes**:
- Comprehensive test coverage
- All security tests passing
- Integration tests with real packages

### Phase 6: Documentation and Examples (2-3 hours)
**Objective**: Complete API documentation and usage examples

#### Step 6.1: API Documentation
Create comprehensive docstrings and README:
```python
class AgenticRuntime:
    """
    Core runtime for loading and interpreting compiled security agent packages.
    
    Provides context-aware security guidance for IDE integration.
    Supports model-agnostic LLM interfaces for flexible deployment.
    """
```

#### Step 6.2: Usage Examples
Create example implementations:
```python
# Example: IDE Integration
runtime = AgenticRuntime()
runtime.load_agent("web-security-specialist")

context = {"file_path": "src/api.py", "content": "..."}
guidance = runtime.get_guidance(context)
```

#### Step 6.3: Integration Patterns
Document common integration scenarios:
- Claude Code integration
- VS Code extension pattern
- CLI tool usage
- CI/CD pipeline integration

**Expected Outcomes**:
- Complete API documentation
- Working usage examples
- Integration pattern documentation

## Success Criteria

### Acceptance Criteria Mapping
✅ **AC1**: Core runtime component created that parses compiled agent JSON packages
✅ **AC2**: Runtime successfully loads rules_detail and validation_hooks from packages  
✅ **AC3**: Context-aware rule selection function implemented
✅ **AC4**: Model-agnostic LLM interface with clear provider abstraction

### Verification Checklist
- [ ] All 5 compiled agent packages load successfully
- [ ] Rule selection works across different file types
- [ ] LLM interface supports multiple providers
- [ ] Security tests pass for malicious input handling
- [ ] Performance meets sub-2 second response requirement
- [ ] Integration tests pass with real package data
- [ ] Documentation complete with examples

## Time Estimation
- **Total Estimated Time**: 16-21 hours
- **Critical Path**: Phases 1-4 (core implementation)
- **Dependencies**: Story 1.3 completion (satisfied)
- **Buffer Time**: 20% added for unexpected issues

## Risk Mitigation

### Technical Risks
**Risk**: Package loading performance issues
**Mitigation**: Implement lazy loading and caching strategies

**Risk**: JSON parsing security vulnerabilities  
**Mitigation**: Use safe parsing with size limits and validation

**Risk**: Rule selection accuracy issues
**Mitigation**: Comprehensive testing with diverse file contexts

### Dependency Risks
**Risk**: Compiled packages from Story 1.3 are malformed
**Mitigation**: Package validation with clear error reporting

**Risk**: Missing Python dependencies
**Mitigation**: Update requirements.txt with all needed packages

### Timeline Risks
**Risk**: LLM interface complexity underestimated
**Mitigation**: Start with simple mock interface, expand iteratively

**Risk**: Security testing uncovers critical issues
**Mitigation**: Allocate extra time for security issue resolution

### Rollback Plan
If critical issues arise:
1. Implement minimal viable runtime with single package support
2. Defer advanced context filtering to future story
3. Use simple string-based LLM interface initially
4. Prioritize security over feature completeness

## Next Steps
- **Story 2.2**: Implement Claude Code sub-agent integration
- **Story 2.3**: Manual on-demand execution capabilities
- **Integration**: Connect runtime to actual IDE platforms
- **Monitoring**: Add telemetry for runtime performance tracking
- **Maintenance**: Establish package update workflows

## Implementation Notes
- Focus on security-first implementation throughout
- Maintain compatibility with all 5 agent package types
- Design for extensibility to support future agent types
- Prioritize performance for real-time IDE integration
- Ensure comprehensive error handling and logging